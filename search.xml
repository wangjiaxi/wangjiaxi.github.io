<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用turtle实现动画效果]]></title>
    <url>%2F2020%2F12%2F02%2F%E4%BD%BF%E7%94%A8turtle%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[众所周知，turtle能够像画笔一样来作图。一个绘图程序运行后，我们能够像看动画一样观看整个绘图过程。但是今天说的动画可和它不太一样。 我们可以用下面的函数调整画笔的速度。 12turtle.speed(1)turtle.speed(10) 在官方文档中，turtle.speed()的参数是0-10的整数，从1到10速度递增。0比较特殊，速度最快，几乎是瞬间完成。 12345678910111213141516171819202122import turtle, timet1 = turtle.Turtle()t2 = turtle.Turtle()t3 = turtle.Turtle()pens = [t1, t2, t3]for i in range(len(pens)): pens[i].pu() pens[i].goto(-100, -100 + 50 * i) pens[i].pd()t1.speed(1)t2.speed(5)t3.speed(0)t1.fd(300)time.sleep(2)t2.fd(300)time.sleep(2)t3.fd(300) 效果比较明显： 可以说，这是一种动画的效果，毕竟能够看到绘画的全过程嘛。但是这个不是今天的重点，今天要讲的是真正的动画。 赶紧进入正题，要想使画面动起来，肯定是先画出主体，再将它移动。这里我们先看一个奇葩转圈图。 “很快啊！” ——马老师 下面看一下代码，为什么画完之后会转起来？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import turtleturtle.speed(0)turtle.Screen().bgcolor('black')# 这个函数主要是画出一个奇葩图形，你想转什么就画什么def arm(col): turtle.begin_fill() turtle.color(col) turtle.fd(60) turtle.lt(60) turtle.fd(60) turtle.rt(60) turtle.fd(60) turtle.rt(60) turtle.fd(60) turtle.lt(60) turtle.fd(60) turtle.lt(120) turtle.fd(120) turtle.lt(60) turtle.fd(120) turtle.lt(60) turtle.fd(120) turtle.lt(120) turtle.end_fill()# 这个函数可以画出我们转动的主体，我的主体是6个不同颜色的armdef turn(angle): turtle.seth(angle) arm('red') turtle.lt(60) arm('orange') turtle.lt(60) arm('yellow') turtle.lt(60) arm('green') turtle.lt(60) arm('blue') turtle.lt(60) arm('purple') turtle.lt(60) turtle.hideturtle()angle = 0 # 设置一个初始角度while True: turtle.clear() turn(angle) turtle.tracer(n=1000000000) angle += 15 # 每次循环角度都增加15度 这里两个自定义函数都很好理解，主要看一下 turtle.tracer()，它的意思大概是将之前画过的作品重复一次，n的大小就是重复的速度，也就是说n如果很大，就可以瞬间完成刚才的画作。所以循环中的过程可以理解为（图有些丑）： graph TD B((开始)) -->C{while True} C --> D[clear清屏] D[clear清屏] --> E[seth改变角度] E[seth改变角度] --> F[tracer再画一次] F[tracer再画一次] --> G[角度增加15] G[角度增加15] --> C 所以，图中的6个arm就转起来了，修改每次循环的角度可以调整旋转速度和方向哦。（负数为反方向）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PygameZero制作Pacman]]></title>
    <url>%2F2020%2F11%2F28%2FPygameZero%E5%88%B6%E4%BD%9CPacman%2F</url>
    <content type="text"><![CDATA[本篇来介绍Pacman的PygameZero实现。 先上代码，后边补上讲解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import pgzrunimport randomWIDTH = 500HEIGHT = 500pacman = Actor('向右的吃豆人')pacman.pos = [250, 250]bean1 = Actor('豆子')bean1.x = random.randint(100, 400)bean1.y = random.randint(100, 400)bean2 = Actor('豆子')bean2.x = random.randint(100, 400)bean2.y = random.randint(100, 400)bean3 = Actor('豆子')bean3.x = random.randint(100, 400)bean3.y = random.randint(100, 400)beans = [bean1, bean2, bean3]score = 0def draw(): screen.blit('游戏背景', [0, 0]) pacman.draw() for i in beans: i.draw() screen.draw.text(str(score), [15, 15], color='orange', fontsize=30)def on_key_down(key): if key == keys.LEFT: pacman.image = '向左的吃豆人' if key == keys.RIGHT: pacman.image = '向右的吃豆人' if key == keys.UP: pacman.image = '向上的吃豆人' if key == keys.DOWN: pacman.image = '向下的吃豆人' if key == keys.SPACE: print(score)def update(): global score if pacman.image == '向左的吃豆人': pacman.x -= 5 if pacman.image == '向右的吃豆人': pacman.x += 5 if pacman.image == '向上的吃豆人': pacman.y -= 5 if pacman.image == '向下的吃豆人': pacman.y += 5 for i in beans: if pacman.colliderect(i): i.x = random.randint(100, 400) i.y = random.randint(100, 400) score += 1 print(score) if pacman.x &lt; 0 or pacman.x &gt; 500 or pacman.y &lt; 0 or pacman.y &gt; 500: score -= 3 print(score) pacman.pos = [250, 250] if score &lt; 0: exit()pgzrun.go()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python输出百分比和有效数字]]></title>
    <url>%2F2020%2F05%2F13%2FPython%E8%BE%93%E5%87%BA%E7%99%BE%E5%88%86%E6%AF%94%E5%92%8C%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[目录： 输出百分数 输出有效数字 输出百分数方式1：直接使用参数格式化：{:.2%}{:.2%}： 显示小数点后2位 显示小数点后2位： 123print('percent: &#123;:.2%&#125;'.format(42 / 50))percent: 84.00% 不显示小数位：{:.0%}，即，将2改为0： 123print('percent: &#123;:.0%&#125;'.format(42 / 50))percent: 84% 方式2：格式化为float，然后处理成%格式： {:.2f}%与方式1的区别是： 需要对42/50乘以 100 。 方式2的%在{ }外边，方式1的%在{ }里边。 显示小数点后2位： 123print('percent: &#123;:.2f&#125;%'.format(42 / 50 * 100))percent: 84.00% 显示小数点后1位： 123print('percent: &#123;:.1f&#125;%'.format(42 / 50 * 100))percent: 84.0% 只显示整数位： 123print('percent: &#123;:.0f&#125;%'.format(42 / 50 * 100))percent: 84% 说明{ }的意思是对应format()的一个参数，按默认顺序对应，参数序号从0开始，{0}对应format()的第一个参数，{1}对应第二个参数。例如： 默认顺序： 123print('percent1: &#123;:.2%&#125;, percent2: &#123;:.1%&#125;'.format(42 / 50, 42 / 100))percent1: 84.00%, percent2: 42.0% 指定顺序：{1:.1%}对应第2个参数； {0:.1%}对应第1个参数。 123print('percent2: &#123;1:.1%&#125;, percent1: &#123;0:.1%&#125;'.format(42 / 50, 42 / 100))percent2: 42.0%, percent1: 84.0% 输出有效数字用自带的decimal模块12345from decimal import *getcontext().prec = 6Decimal(1)/Decimal(7)# 结果为Decimal('0.142857')，六个有效数字]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kaggle项目之泰坦尼克幸存预测]]></title>
    <url>%2F2020%2F05%2F12%2Fkaggle%E9%A1%B9%E7%9B%AE%20-%20%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%B9%B8%E5%AD%98%E9%A2%84%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[kaggle是一个机器学习竞赛平台。 项目简介作为kaggle的第一个项目，很有必要记录一下遇到的问题和解决的办法，哈哈哈。kaggle是个国外网站，首先加载很慢……其次呢是鄙人英语水平实在不好，全程翻译……在项目描述中，推荐通过这个大佬的教程来完成这个项目，所以下面的内容全都是跟这位大佬的解说，一步一步进行的。 Steps~教程的右侧就是操作步骤喽！ Getting Started首先我们需要点击参加比赛按钮，并且接受规则什么的，然后就可以点击data标签，来获取需要的数据集了！我们可以使用gender_submission.csv这个文件，来尝试提交一下答案~这个数据比较偏激，只是用来测试提交答案功能的，不过我们应该提交的答案，需要和它格式相同，也就是说这是一个答案模板~ 这里我上传答案若干次，都失败了，原因不明…… Your coding environment这里就要开始搭建环境了，新建一个kaggle的notebook~这篇就是诞生于此~接下开，就是复制大佬的代码，从导入数据开始! 下面的代码，新建笔记本时就自动生成了，主要是导入需要的库。比如数据分析必备的numpy和pandas，读写文件需要的os。 1234567891011121314151617# This Python 3 environment comes with many helpful analytics libraries installed# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python# For example, here's several helpful packages to loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files are available in the read-only "../input/" directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# You can write up to 5GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save &amp; Run All" # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session 下面的代码是用来读取训练数据的，运行后展示前5行结果。 12train_data = pd.read_csv("/kaggle/input/titanic/train.csv")train_data.head() 下面的代码是用来读取测试数据的，运行后展示前5行结果。 12test_data = pd.read_csv("/kaggle/input/titanic/test.csv")test_data.head() Improve your score假如我们的gender_submission.csv文件成立，也就是女性全部存活，男性全部死亡。 1234women = train_data.loc[train_data.Sex == 'female']["Survived"]rate_women = sum(women)/len(women)print("% of women who survived:", rate_women) 1234men = train_data.loc[train_data.Sex == 'male']["Survived"]rate_men = sum(men)/len(men)print("% of men who survived:", rate_men) 通过结果我们可以看出，船上有74%女性幸存，而只有19%的男性幸存。所以猜测的“女性全部存活，男性全部死亡”这个结论，是非常贴近结果的！！但是我们还有其他的指标，不能只看性别，还要看年龄等等。此时就可以请机器学习来自动完成~这里我们使用随机森林来实现（我也不知道什么是随机森林，先看例子吧）。二话不说贴代码： 123456789101112131415from sklearn.ensemble import RandomForestClassifiery = train_data["Survived"]features = ["Pclass", "Sex", "SibSp", "Parch"]X = pd.get_dummies(train_data[features])X_test = pd.get_dummies(test_data[features])model = RandomForestClassifier(n_estimators=100, max_depth=5, random_state=1)model.fit(X, y)predictions = model.predict(X_test)output = pd.DataFrame(&#123;'PassengerId': test_data.PassengerId, 'Survived': predictions&#125;)output.to_csv('my_submission.csv', index=False)print("Your submission was successfully saved!") 秃然就完成了！我们可以点击右上角的Save Version，并选择Save &amp; Run All (Commit)这个按钮，保存就可以了。保存以后我们点击Save Version后的数字，进入笔记本，再选择通过Viewer打开，就可以看到和大佬教程一样的格式了~ 提交结果程序生成了一个my_submission.csv文件，可以在Viewer中的output标签看到，点击提交就算完成比赛了~ 小结到此这个项目就算完成了，教程的最后是大佬的机器学习课程广告（怪不得一直在教程里说不用理解代码，抄就完事），据说只有3个小时，会讲解刚刚抄的代码。通过这个项目，我们基本了解了如何参加一次kaggle比赛，从报名到提交答案，每个步骤几乎都涉及过，搞起来！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python题目 - 回文质数]]></title>
    <url>%2F2020%2F01%2F09%2FPython%E9%A2%98%E7%9B%AE%20-%20%E5%9B%9E%E6%96%87%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述因为 151 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 151 是回文质数。 写一个程序来找出范围 [a,b] (5 \le a &lt; b \le 100,000,000)a,b( 一亿)间的所有回文质数。 输入格式第 1 行: 二个整数 a 和 b . 输出格式输出一个回文质数的列表，一行一个。 输入输出样例输入15 500 输出1234567891011125711101131151181191313353373383 超时实现123456789101112# 获得输入ab = input().split()a = int(ab[0])b = int(ab[1])for i in range(a, b + 1): if i % 2 == 1: if str(i)[::-1] == str(i): # 判断是否回文数 for j in range(2, int(i ** 0.5) + 1): # 判断是否质数 if i % j == 0: break else: print(i) # 是则打印 大佬方法埃氏筛 12345678910def prime_numbers(n): number = [1]*(n+1) # 初始化，1表示全部为质数 for i in range(2, int((n**0.5))+1): if number[i]: # 如果下标i对应的数字i是素数 for j in range(i*i, n+1, i): # 素数i的各个倍数 number[j] = 0 j += 1 for x in range(2, n+1): if number[x]: print(x)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm控制台自动换行]]></title>
    <url>%2F2019%2F12%2F23%2FPyCharm%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[点击File -&gt; Settings -&gt; Editor -&gt; General -&gt; Console,勾选下图项即可。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中if后直接加变量]]></title>
    <url>%2F2019%2F12%2F23%2FPython%E4%B8%ADif%E5%90%8E%E7%9B%B4%E6%8E%A5%E5%8A%A0%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[python中有时候会使用if语句，后边直接加一个变量，而不是一个布尔表达式，这是在判断神马呢？ 其实意思是判断这个变量是否有值，这个值需要是非零非空的值，这行代码返回True或False。Python中除了’’、””、0、()、[]、{}、None为False之外，其他的都是True。举例 123456ls = [[], 0, '', "", &#123;&#125;, (), [1], 2, '3', "4", &#123;5&#125;, (6)]for i in ls: if i: print('i =', i, '有值') else: print('i =', i, '没值') 结果123456789101112i = [] 没值i = 0 没值i = 没值i = 没值i = &#123;&#125; 没值i = () 没值i = [1] 有值i = 2 有值i = 3 有值i = 4 有值i = &#123;5&#125; 有值i = 6 有值]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用SQL]]></title>
    <url>%2F2019%2F11%2F12%2F%E5%AE%9E%E7%94%A8SQL%2F</url>
    <content type="text"><![CDATA[在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。 插入或替换如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入： 1REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &apos;小明&apos;, &apos;F&apos;, 99); 若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。 插入或更新如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句： 1INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &apos;小明&apos;, &apos;F&apos;, 99) ON DUPLICATE KEY UPDATE name=&apos;小明&apos;, gender=&apos;F&apos;, score=99; 若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。 插入或忽略如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句： 1INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &apos;小明&apos;, &apos;F&apos;, 99); 若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。 快照如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT： 12-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1; 新创建的表结构和SELECT使用的表结构完全一致。 写入查询结果集如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。 例如，创建一个统计成绩的表statistics，记录各班的平均成绩： 123456CREATE TABLE statistics ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, average DOUBLE NOT NULL, PRIMARY KEY (id)); 然后，我们就可以用一条语句写入各班的平均成绩： 1INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id; 确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果： 123456789&gt; select * from statistics;+----+----------+--------------+| id | class_id | average |+----+----------+--------------+| 1 | 1 | 86.5 || 2 | 2 | 73.666666666 || 3 | 3 | 88.333333333 |+----+----------+--------------+3 rows in set (0.00 sec)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python切片]]></title>
    <url>%2F2019%2F11%2F11%2FPython%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[在组合数据类型中，经常会用到切片操作，也就是从列表（或其他）中取出特定范围或者按一定规律来取出元素，这个就叫切片。Python中使用中括号[]切片非常方便，可以简化代码。 什么是切片取一个list或tuple的部分元素是非常常见的操作，这个应该就叫切片了。比如，一个list如下： 1&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;] 取前3个元素，应该怎么做？ 笨办法： 12&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 之所以是笨办法是因为，扩展一下——取前N个元素就没辙了。 取前N个元素，也就是索引为0-(N-1)的元素，可以用循环： 1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 切片来了对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 12&gt;&gt;&gt; L[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 也可以从索引1开始，取出2个元素出来： 12&gt;&gt;&gt; L[1:3][&apos;Sarah&apos;, &apos;Tracy&apos;] 类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 1234&gt;&gt;&gt; L[-2:][&apos;Bob&apos;, &apos;Jack&apos;]&gt;&gt;&gt; L[-2:-1][&apos;Bob&apos;] 记住倒数第一个元素的索引是-1。 切片操作十分有用。我们先创建一个0-99的数列： 123&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 可以通过切片轻松取出某一段数列。比如前10个数： 12&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： 12&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数： 12&gt;&gt;&gt; L[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个： 12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 所有数，每5个取一个： 12&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 甚至什么都不写，只写[:]就可以原样复制一个list： 12&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： 12&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2) 字符串&#39;xxx&#39;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 1234&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 在很多编程语言中，针对字符串提供了很多各种截取函数（例如substring），其实目的就是对字符串切片。 Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。 参考：https://www.liaoxuefeng.com/wiki/1016959663602400/1017269965565856]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PygameZero中文文档 - 3]]></title>
    <url>%2F2019%2F08%2F28%2FPygameZero%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%20-%203%2F</url>
    <content type="text"><![CDATA[Pygame Zero会自动识别并调用您定义的事件钩，这种方法可以使您不必自己实现事件循环机制。 游戏循环挂钩一个典型的循环钩看起来有点像这样： 1234while game_has_not_ended(): process_input() update() draw() 输入处理要更加复杂一些，但Pygame Zero可以让您在自己的游戏模块中轻松地定义update()和draw()函数。 draw()​ 当需要重绘游戏窗口时，Pygame Zero就会调用这个函数。 ​ draw() 函数必须是一个无参函数。 ​ Pygame Zero会在游戏窗口需要重绘时进行计算，以避免屏幕没有任何改变时重绘。它将在游戏循环的每一 步的以下的情况中绘制屏幕： 如果已经定义了一个update()功能（见下文）。 如果有时钟事件。 如果一个输入事件被触发。 如果您尝试修改draw()函数中的某些内容或使其具有动画效果，这种做法会让你很难受。例如，这段代码就是错误的：外星人并不一定会在屏幕上继续移动： 123def draw(): alien.left += 1 alien.draw() ​ 正确的做法是使用update()函数来修改或让元素动起来，draw()函数仅仅是在屏幕上绘制画面。 12345def draw(): alien.draw()def update(): alien.left += 1 update()或 update(dt)​ Pygame Zero会调用这个函数来实现您的游戏逻辑。update()会被重复调用，每秒钟60次。 ​ 编写update()函数有两种不同的方法。 ​ 在简单的游戏中，您可以假设每次调用update()函数都经过了一小段时间（几分之一秒）。也许你甚至并不关心时间的步长多大：您可以只按每帧固定的像素数移动对象（或者通过一个常量来让它们加速等等）。 ​ 一种更高级的方法，是根据两次调用之间实际花费的时间，来进行移动和物理计算。这样可以提供更流畅的动画，但涉及的计算可能更难，并且当时间步长变大时，你要更小心的处理来避免意外发生。 ​ 要使用基于时间的方法，您可以修改update()函数让它只接收一个参数。这样做以后，Pygame Zero会以秒为单位传递经过的时间。您可以使用它来衡量有段移动的计算。 事件处理挂钩与游戏循环挂钩类似，你的Pygame Zero程序可以通过定义具有特定名称的函数来响应输入事件。 有点像update()函数这种情况，Pygame Zero会通过检查事件处理函数来决定如何调用。所以你不需要让事件处理函数传参。例如，Pygame Zero会调用 on_mouse_down函数的任何变体： 1234567891011def on_mouse_down(): print("Mouse button clicked")def on_mouse_down(pos): print("Mouse button clicked at", pos)def on_mouse_down(button): print("Mouse button", button, "clicked")def on_mouse_down(pos, button): print("Mouse button", button, "clicked at", pos) 它通过查看参数的名称来完成此操作，所以参数必须完全拼写正确，就像上边代码列出的一样。每个事件挂钩都有一组可以使用的不同参数，如下所述。 on_mouse_down([pos][, button]) ​ 按下鼠标按键时调用。 参数： pos – 一个元组(x, y) 表示按键按下时鼠标指针的位置。 button – 一个 mouse 枚举值，表示按下的鼠标按键。 on_mouse_up([pos][, button]) ​ 释放鼠标按键时调用。 参数： pos – 一个元组(x, y) 表示按键释放时鼠标指针的位置。 button – 一个 mouse 枚举值，表示释放的鼠标按键。 on_mouse_move([pos][, rel][, buttons]) ​ 移动鼠标时调用。 参数： pos – 一个元组(x, y) 表示鼠标指针移动到的位置。 rel – 一个元组(delta_x, delta_y)表示鼠标指针位置的变化。 buttons – 一组 mouse枚举值，表示在移动过程中按下的按键。 要处理鼠标拖动，请使用下面这样的代码： 1234def on_mouse_move(rel, buttons): if mouse.LEFT in buttons: # the mouse was dragged, do something with `rel` ... on_key_down([key][, mod][, unicode]) ​ 按下按键时调用。 参数： key – 一个整数，表示按下的键。 unicode – 相关时键入的字符编码。 并非所有按键都会产生可打印的字符 - 许多可能是控制字符。如果按键与Unicode字符编码不对应，则为空字符串。 mod – 按下的修饰键的位掩码。 on_key_up([key][, mod]) ​ 释放按键时调用。 参数: key – 一个整数，表示释放的按键。 mod – 按下的修饰键的位掩码。 on_music_end() ​ 音乐曲目结束时调用。 ​ 请注意，如果将音轨配置为循环，则不会调用此方法。 鼠标和键盘按键内置对象mouse，keys可用于确定在上述事件中按下了哪些按钮或按键。 请注意，鼠标滚轮事件显示为按下按钮 WHEEL_UP/ WHEEL_DOWN按钮常量。 mouse类 可以由on_mouse_*处理程序接收的内置枚举按钮 。 LEFT MIDDLE RIGHT WHEEL_UP WHEEL_DOWN keys类 可由on_key_* 处理程序接收的内置枚举按钮。 BACKSPACE TAB CLEAR RETURN PAUSE ESCAPE SPACE EXCLAIM QUOTEDBL HASH DOLLAR AMPERSAND QUOTE LEFTPAREN RIGHTPAREN ASTERISK PLUS COMMA MINUS PERIOD SLASH K_0 K_1 K_2 K_3 K_4 K_5 K_6 K_7 K_8 K_9 COLON SEMICOLON LESS EQUALS GREATER QUESTION AT LEFTBRACKET BACKSLASH RIGHTBRACKET CARET UNDERSCORE BACKQUOTE A B C D E F G H I J K L M N O P Q R S T U V W X Y Z DELETE KP0 KP1 KP2 KP3 KP4 KP5 KP6 KP7 KP8 KP9 KP_PERIOD KP_DIVIDE KP_MULTIPLY KP_MINUS KP_PLUS KP_ENTER KP_EQUALS UP DOWN RIGHT LEFT INSERT HOME END PAGEUP PAGEDOWN F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 NUMLOCK CAPSLOCK SCROLLOCK RSHIFT LSHIFT RCTRL LCTRL RALT LALT RMETA LMETA LSUPER RSUPER MODE HELP PRINT SYSREQ BREAK MENU POWER EURO LAST 此外，您可以访问一组表示修饰键的常量： keymods类 表示在on_key_up/ on_key_down事件期间可能已被压下的修饰键的常量。 LSHIFT RSHIFT SHIFT LCTRL RCTRL CTRL LALT RALT ALT LMETA RMETA META NUM CAPS MODE]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PygameZero中文文档 - 2]]></title>
    <url>%2F2019%2F08%2F28%2FPygameZero%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%20-%202%2F</url>
    <content type="text"><![CDATA[本篇介绍了FlappyBird的PygameZero实现，为了方便与Scratch比较，所以没有加入计分功能。 舞台在Scratch舞台区的内容大概是这样的： 除了舞台背景之外，还有三个对象：小鸟，上方管道和下方管道，对应的Pygame Zero代码是把这些对象都设置为 Actors ： 123bird = Actor('bird1', (75, 200))pipe_top = Actor('top', anchor=('left', 'bottom'))pipe_bottom = Actor('bottom', anchor=('left', 'top')) 在Pygame Zero中，我们还必须保证绘制这些对象。原则上，这为绘制场景提供了一些灵活性： 12345def draw(): screen.blit('background', (0, 0)) pipe_top.draw() pipe_bottom.draw() bird.draw() 管道移动不管小鸟如何，管道都以恒定的速度移动。当它们离开屏幕的左侧时，会向右环绕，并且他们的垂直位置是随机的。 在Scratch中，可以通过为上方管道和下方管道创建两个不同脚本来实现。 总结一下这里都干了啥： 当管道离开屏幕的左侧时，条件x position &lt; -240为真，这将会重置管道。 变量pipe_height用于改变管道在竖直方向上的位置。因为它们之间空隙高度应保持不变，我们无法随机两个高度。因此，我们只在其中一个脚本设置了pipe_height随机的逻辑，而另一个脚本则没有这个逻辑。 脚本set y position to pipe height +/- 230让上方的管道在pipe_height之上，让下方管道在pipe_height之下。 在Pygame Zero中代码就简单多了。我们可以定义一个函数不停的更新两个管道。当然我把更新管道的过程分成了两部分，这样管道重置的过程就更加清晰： 1234567891011121314151617import randomWIDTH = 400HEIGHT = 708GAP = 130SPEED = 3def reset_pipes(): pipe_gap_y = random.randint(200, HEIGHT - 200) pipe_top.pos = (WIDTH, pipe_gap_y - GAP // 2) pipe_bottom.pos = (WIDTH, pipe_gap_y + GAP // 2)def update_pipes(): pipe_top.left -= SPEED pipe_bottom.left -= SPEED if pipe_top.right &lt; 0: reset_pipes() 与Scratch一个小小的不同，是我可以把需要复用的值定义为“常量”，用大写字母表示。当我需要调整游戏时，我只需要修改一次值就好了。比如在上面的例子中，当我需要增大或者减小空隙高度的时候，我只需要简单的修改 GAP 的值就可以了。 与Scratch代码最大的不同在于，Python代码中没有 forever 循环。这是Scratch和大多数基于文本的编程语言的区别：你必须通过重复的更新一小步动画的方式来更新游戏。重复的过程让Pygame Zero有机会处理输入或者刷新屏幕。如此循环往复就会形成游戏了，所以任何循环都必须快速完成。 当你需要更新一步动画的时候，Pygame Zero会调用 update() 函数，所以我们只需要调用一次 update_walls 12def update(): update_walls() 小鸟上面介绍的如何把Scratch逻辑转换为Python代码的模式，同样适用于小鸟的逻辑。我们首先来看 一下Python代码。 用来更新小鸟相关的代码被整合到了一个叫做update_bird 的函数中。 根据重力移动小鸟这段代码包含的第一部分，是根据重力移动小鸟的相关代码： 1234567891011GRAVITY = 0.3# 小鸟的初始状态bird.dead = Falsebird.vy = 0def update_bird(): uy = bird.vy bird.vy += GRAVITY bird.y += bird.vy bird.x = 75 这是一个很简单的重力公式： GRAVITY 指的是 重力加速度 加速度是指速度的改变 速度代表小鸟的位置的改变 因此我们需要追踪一个 bird.vy 变量，表示小鸟在 y 方向的速度。这是我们新定义的一个变量，而不是Pygame Zero提供的。 GRAVITY 指的是 重力加速度 ：GRAVITY 大于0 加速度是指速度的改变：把 GRAVITY 加到 bird.vy 速度代表小鸟的位置的改变: 把 bird.vy 加到 bird.y 上 注意！小鸟水平方向的位置是始终不变的，整个游戏中小鸟的 x 坐标始终是 75。我们通过让管道移向小鸟来模拟小鸟的运动。这看起来就像是一个移动的镜头在跟随着小鸟，所以游戏中并不需要 vx 变量。 让小鸟拍打翅膀接下来的部分是让小鸟可以拍打翅膀： 12345if not bird.dead: if bird.vy &lt; -3: bird.image = 'bird2' else: bird.image = 'bird1' 这会检查小鸟是向上移动还是向下移动。如果小鸟向上移动我们设置图片为 bird2 ，否则设置图片为bird1 。（-3是通过不断试错得出的经验值，这样游戏看起来会更加真实。） 检测小鸟是否撞管子接下来我们要检测小鸟有没有撞管子。 123if bird.colliderect(pipe_top) or bird.colliderect(pipe_bottom): bird.dead = True bird.image = 'birddead' 如果小鸟撞到管子了，我们就把变量 bird.dead 值设置为 True。这是一个布尔值表示非假即真，这样我们可以方便的检测小鸟是否还活着。如果小鸟挂了，我们就不需要响应玩家的输入了。 检测小鸟是否触顶/触底最后我们检测一下小鸟有没有触底或触顶（屏幕的上下边缘），如果是的话就重置小鸟的状态和属性： 12345if not 0 &lt; bird.y &lt; 720: bird.y = 200 bird.dead = False bird.vy = 0 reset_pipes() 重置小鸟，为什么要调用 reset_pipes() 呢？是因为我们把管道代码定义成一个独立的函数，所以每当我们想重置游戏时都可以调用它。这样，小鸟回到初始位置时会让玩家有一段反应的时间，这样才是一个友好的游戏。 放在update()函数中再次重申，以上过程的每一帧都要调用，因此我们把这些操作放到 update_date() 函数： 123def update(): update_walls() update_bird() 响应玩家输入控制小鸟逻辑的最后一部分是必须响应玩家控制。当我们按键时要让小鸟向上飞。当你按了键盘上的任何一个按键，Pygame Zero都会调用 on_key_down 函数（需要先定义）： 12345FLAP_VELOCITY = -6.5def on_key_down(): if not bird.dead: bird.vy = FLAP_VELOCITY 这里，如果小鸟没挂的话，我们设置小鸟的 vy 为一个负数：在Pygame Zero中，意味着小鸟在向上移动。 无论Scratch还是Python代码，你都能够找到许多相似之处： Scratch和Pygame Zero最大的区别在于： 在Pygame Zero中你不能无限循环，只能更新每一帧并然后重复 坐标系不同。Pygame Zero中屏幕的左上角是原点 x = 0, y = 0, x轴正方向跟Scratch一样是从左向右的，但是 y 轴指向屏幕下方！这也是 为什么GRAVITY 是正数而 FLAP_VELOCITY 是负数了。 bird.dead 是一个布尔值，所以我们可以写 if not bird.dead 而不是像Scratch一样写 dead = 0。 总结许多Scratch种的概念可以直接迁移到Pygame Zero中。 下面是一些对比： In Scratch In Pygame Zero change y by 1 (上) bird.y -= 1 change y by -1 (下) bird.y += 1 set costume to &lt;name&gt; bird.image = &#39;name&#39; if dead = 0 if not bird.dead: set dead to 0 bird.dead = False if touching Top? if bird.colliderect(pipe_top) When Flag clicked… forever 把代码放入update()函数中 When [any] key pressed def on_key_down(): pick random a to b import random to load the random module, then random.randint(a, b) (0, 0) 是舞台中心 (0, 0) 是窗口左上角 在某些情况下，Python中的代码更简单，因为Python的代码可以组织成更易于阅读的方式。 Pygame Zero中的角色也让我们更加简单的使用坐标。我们使用 anchor 位置来定位管道，我们通过检测管道的 pipe_top.right &lt; 0 而不是 if x position &lt; -240 来判断管道是否离开了屏幕。 全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# flappybird.pyimport randomimport pgzrunbird = Actor('bird2', (75, 200))pipe_top = Actor('top', anchor=('left', 'bottom'))pipe_bottom = Actor('bottom', anchor=('left', 'top'))WIDTH = 400HEIGHT = 708GAP = 150SPEED = 3def reset_pipes(): pipe_gap_y = random.randint(200, HEIGHT - 200) pipe_top.pos = (WIDTH, pipe_gap_y - GAP // 2) pipe_bottom.pos = (WIDTH, pipe_gap_y + GAP // 2)def update_pipes(): pipe_top.left -= SPEED pipe_bottom.left -= SPEED if pipe_top.right &lt; 0: reset_pipes()GRAVITY = 0.3bird.dead = Falsebird.vy = 0def update_bird(): bird.image = 'bird2' bird.vy += GRAVITY bird.y += bird.vy bird.x = 75 if bird.colliderect(pipe_top) or bird.colliderect(pipe_bottom): bird.dead = True bird.image = 'dead' if not bird.dead: if bird.vy &lt; -3: bird.image = 'bird2' else: bird.image = 'bird1' if not 0 &lt; bird.y &lt; 720: bird.y = 200 bird.dead = False bird.vy = 0 reset_pipes()def draw(): screen.blit('background', (0, 0)) pipe_top.draw() pipe_bottom.draw() bird.draw()def update(): update_pipes() update_bird()FLAP_VELOCITY = -6.5def on_key_down(): if not bird.dead: bird.vy = FLAP_VELOCITYdef on_mouse_down(): if not bird.dead: bird.vy = FLAP_VELOCITYpgzrun.go() 小提示：导入pgzrun后，调用pgzrun.go()可以直接运行程序，而不需要在命令行中使用命令pgzrun flappybird.py。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PygameZero中文文档 - 1]]></title>
    <url>%2F2019%2F08%2F27%2FPygameZero%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%20-%201%2F</url>
    <content type="text"><![CDATA[最近在研究PygameZero这个库，用来开发简单游戏的。发现官方文档翻译很少，所以自己胡乱翻译一些，欢迎大家批评指正。 创建窗口首先，新建一个python空白文件，并保存为 intro.py。 运行一下命令来验证文件可以正常运行并创建一个窗口。 1pgzrun intro.py Pygame Zero所有设置都是默认可选，所以一个空的文件也是一个合法可以运行的Pygame Zero脚本！ 好神奇有木有！ 单击窗口的关闭按钮或者按 Ctrl+Q ( ⌘-Q on Mac)快捷键退出游戏。如果游戏卡住了， 你可以在终端窗口按 Ctrl+C 快捷键。 绘制窗口的背景然后，让我们添加一个 draw()函数并且设置窗口的大小。每当需要刷新(重绘)窗口的时候， Pygame Zero就会调用这个函数。 在 intro.py文件添加以下代码： 12345WIDTH = 300HEIGHT = 300def draw(): screen.fill((128, 0, 0)) 重新运行 pgzrun intro.py 脚本，游戏窗口变成了红色的正方形。 这段代码的作用是啥？ WIDTH 以及 HEIGHT 指明了窗口的宽和高。这段代码把窗口设置为300x300大小。 screen 是内置的代表窗口显示的类. screen类有。很多负责绘制精灵和图形的函数。调用 screen.fill() 方法可以用指定一个颜色元组 (red, green, blue) ，然后用纯色填充窗口。 (128, 0, 0) 是暗红色。试着 改变RGB颜色值，然后查看代码运行效果。 接下来让我们设置一个我们生成动画的精灵。 绘制一个精灵在我们绘制任意东东之前，我们需要一个外星人alien精灵图片。你可以右键单击这张图，然后选择图片另存为。 这个精灵图片是支持透明色的png图片，非常适合在游戏里使用。这张图片为深色背景设计，所以 只有当你程序运行的时候才能够看到外星人的头盔。 小技巧： 你可以在 kenney.nl 网站找到包括这张图在内的大量免费精灵图片。这张图是 Platformer Art Deluxe pack 的一部分。 只有将图片保存在正确的路径Pygame Zero才能够加载图片。新建一个 images 目录，并且把 图片另存为 alien.png 。文件夹和文件名都是小写，虽然windows不区分文件名的大小写，但是 linux和OSX区分，不然就会陷入一个跨平台兼容性的陷阱。 新建完图片并且另存图片之后，你的项目如下： 1234.├── images/│ └── alien.png└── intro.py images/ 目录是Pygame Zero查找代码中图片的标准默认位置。 内置类 Actor 用来代表一个你绘制到屏幕的图形。 让我们来定义一个在屏幕上显示的图形，修改 intro.py 文件加载图片：、 123456789alien = Actor('alien')alien.pos = 100, 56WIDTH = 500HEIGHT = alien.height + 20def draw(): screen.clear() alien.draw() 哇塞，外星人显示在屏幕上了。通过把字符串 &#39;alien&#39; 作为参数传递给 Actor 类，Pygame Zero自动加载了外星人精灵，并且图片具有位置和大小属性。这样我们就可以根据外星人alien的告诉 设置窗口的高度属性 HEIGHT 。 alien.draw() 方法把外星人精灵绘制到屏幕上的当前位置。 1alien.topright = 0, 10 注意修改topright属性来相对于右上角来修改外星人角色位置的方法。如果外星人角色的右边横坐标为0，外星人角色恰好在屏幕的左侧。然后，我们让外星人角色动起来。在文件底部添加以下代码： 1234def update(): alien.left += 2 if alien.left &gt; WIDTH: alien.right = 0 Pygame Zero在每一帧都会调用 update()函数。通过在每一帧让外星人移动很小的像素数，外星人就会在屏幕上从左向右滑过。一旦外星人左侧的坐标大于窗口的宽度，就让外星人回到左侧重新向右滑动。 处理鼠标单击事件接下来，我们让游戏在单击鼠标的时候，做点不一样的东西。为了实现这个目标我们需要定义 一个 on_mouse_down()函数。在文件下方添加以下代码： 12345def on_mouse_down(pos): if alien.collidepoint(pos): print("Eek!") else: print("You missed me!") 运行游戏，并尝试多次单击外星人角色。 Pygame Zero可以非常聪明的处理你对于函数的调用。如果你定义的函数没有 pos 参数，Pygame 在调用函数的时候就不会传递位置参数。on_mouse_down 方法还有一个 button 按钮参数， 代表单击的鼠标的那个键。因此我们也可以这样定义 on_mouse_down 函数： 12def on_mouse_down(): print("You clicked!") 或者： 123def on_mouse_down(pos, button): if button == mouse.LEFT and alien.collidepoint(pos): print("Eek!") 声音和图像接下来我们让外星人表现受伤的造型，保存一下文件： -保存图片 alien_hurt.png 到 images 目录。 eep.wav - 新建一个叫做 sounds 目录，然后保存 eep.wav 到声音目录。 这时候项目如下图所示: 1234567.├── images/│ └── alien.png│ └── alien_hurt.png├── sounds/│ └── eep.wav└── intro.py sounds/ 是Pygame Zero查找声音文件的默认标准目录。 现在让我们用新的图片和声音资源改写 on_mouse_down 函数: 1234def on_mouse_down(pos): if alien.collidepoint(pos): sounds.eep.play() alien.image = 'alien_hurt' 当你单击外星人的时候，你会听到一段声音，精灵也会切换到不开心的外星人。 但是这个游戏还有一个bug，那就是被单击后外星人不会回到开心的造型，但是每次单击的时候，声音会播放。接下来让我们改掉这个bug。 时钟函数如果出了游戏编程之外你对python非常熟悉，你就会知道用 time.sleep() 来插入延时。 你可以像下面这样写代码： 123456def on_mouse_down(pos): if alien.collidepoint(pos): sounds.eep.play() alien.image = 'alien_hurt' time.sleep(1) alien.image = 'alien' 但是不行的是，在游戏中这样写是不合适的。 time.sleep() 阻塞了所有的活动。我们希望 游戏能够继续运行和播放动画。实际上我们需要从 on_mouse_down 返回，然后让游戏在切换 外星人的造型之后还能够继续运行，让 draw() 和 update() 继续跑。 这可难不倒Pygame Zero，因为我们有一个内置的 Clock ，可以让函数延时执行。 首先，让我们重构代码。我们定一个设置外星人手上和返回普通造型的函数： 123456789101112def on_mouse_down(pos): if alien.collidepoint(pos): set_alien_hurt()def set_alien_hurt(): alien.image = 'alien_hurt' sounds.eep.play()def set_alien_normal(): alien.image = 'alien' 运行代码跟之前没啥区别 set_alien_normal() 并没有被调用。但是我们可以用时钟类修改 set_alien_hurt() 方法，这样 set_alien_normal() 就可以延迟一段时间被调用了: 1234def set_alien_hurt(): alien.image = 'alien_hurt' sounds.eep.play() clock.schedule_unique(set_alien_normal, 1.0) clock.schedule_unique() 可以让 set_alien_normal() 方法在1.0 秒后被调用。 schedule_unique() 同时防止同一函数在快速单击的时候被多次安排调用。 尝试下，你会发现外星人alien在1s后恢复正常形态。尝试快速单击外星人，验证外星人只有在最后单击的1s之后才会恢复。 总结我们已经学习如何绘制精灵，播放声音，处理输入时间，以及使用内置的时钟类。 也许你继续完善游戏，可以记录游戏的得分，或者让外星人alien移动的更加诡异。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无监督学习的降维算法及应用]]></title>
    <url>%2F2019%2F04%2F24%2F%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[PCA算法及应用主成分分析（PCA）主成分分析（Principal Component Analysis,PCA）是最常用的一种降维方法，通常用于高位数据集的探索与可视化，还可以用作数据压缩和预处理等。 PCA可以吧具有相关性的高位变量合称为线性无关的低维变量，称为主成分。主成分能够尽可能保留原始数据的信息。 相关术语方差方差是各个样本和样本均值的差和平方和的均值，用来度量一组数据的分散程度。 协方差协方差用于度量两个变量之间的线性相关程度，若两个变量的协方差为0，则可认为二者线性无关。协方差矩阵则是由变量的协方差值构成的矩阵（对称阵）。 特征向量矩阵的特征向量是描述数据集结构的非零向量，并满足如下公式 A是方阵，v是特征向量，λ是特征值 原理原理：矩阵的主成分就是其协方差矩阵对应的特征向量，按照对应的特征值大小进行排序，最大的特征值就是第一主成分，其次是第二主成分，以此类推。 PCA算法应用需求PCA实现高维数据可视化已知鸢尾花数据是4维的，共三类样本。使用PCA实现对鸢尾花数据进行降维，实现在二维平面上的可视化。 实现过程 建立工程，导入sklearn相关包 加载数据并进行降维 按类别对降维后的数据进行保存 降维后数据点的可视化 代码123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-"""Created on Tue Apr 23 15:12:43 2019@author: Jiaxi Wang"""import matplotlib.pyplot as pltfrom sklearn.decomposition import PCAfrom sklearn.datasets import load_irisdata = load_iris()y = data.targetx = data.datapca = PCA(n_components = 2)reduced_X = pca.fit_transform(X)red_x, red_y = [], []blue_x, blue_y = [], []green_x, green_y = [], []for i in range(len(reduced_X)): if y[i] == 0: red_x.append(reduced_X[i][0]) red_y.append(reduced_X[i][1]) elif y[i] == 1: blue_x.append(reduced_X[i][0]) blue_y.append(reduced_X[i][1]) else: green_x.append(reduced_X[i][0]) green_y.append(reduced_X[i][1])plt.scatter(red_x, red_y, c = 'r', marker = 'x')plt.scatter(blue_x, blue_y, c = 'b', marker = 'D')plt.scatter(green_x, green_y, c = 'g', marker = '.')plt.show() 结果 拓展&amp;改进NMF算法及实例非负矩阵分解（NMF）非负矩阵分解（Non-negative Matrix Factorization，NMF）实在矩阵中所有元素均为非负数约束条件之下的矩阵分解方法。 基本思想：给定一个非负矩阵V，NMF能够找到一个非负矩阵W和一个非负矩阵H，使得矩阵W和H的乘积近似等于矩阵V中的值。 W矩阵：基础图像矩阵，相当于从原矩阵V中抽取出来的特征。 矩阵：系数矩阵。 NMF能够广泛应用于图像分析、文本挖掘和语音处理等领域。 矩阵分解优化目标：最小化W矩阵H矩阵的乘积和原始矩阵之间的差别。 基于KL的优化目标，损失函数如下： NMF算法应用需求现有某大学校园网的日志数据，290条大学生的校园网使用情况数据，数据包括用户ID，设备MAC地址，IP地址，开始上网时间，停止上网时间，上网时长，校园网套餐等。利用已有数据，分析学生的上网模式。 需求NMF人脸数据特征提取目标：Olivetti人脸数据共400个，每个数据是64*64大小。由于NMF分解得到的W矩阵相当于从原始矩阵中提取的特征，那么就可以使用NMF对400个人脸数据进行特征提取。 思路通过设置k的大小，设置提取的特征的数目。在本实验中设置k=6，随后将提取的特征以图像的形式展示出来。 建立工程，引入相关包 设置基本参数并加载数据 设置图像的展示方式 创建特征提取的对象NMF，使用PCA作为对比 降维后数据点的可视化 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf-8 -*-"""Created on Wed Apr 24 10:41:47 2019@author: Jiaxi Wang"""from numpy.random import RandomStateimport matplotlib.pyplot as pltfrom sklearn.datasets import fetch_olivetti_facesfrom sklearn import decomposition n_row, n_col = 2, 3n_components = n_row * n_colimage_shape = (64, 64) ################################################################################ Load faces datadataset = fetch_olivetti_faces(shuffle=True, random_state=RandomState(0))faces = dataset.data ###############################################################################def plot_gallery(title, images, n_col=n_col, n_row=n_row): plt.figure(figsize=(2. * n_col, 2.26 * n_row)) plt.suptitle(title, size=16) for i, comp in enumerate(images): plt.subplot(n_row, n_col, i + 1) vmax = max(comp.max(), -comp.min()) plt.imshow(comp.reshape(image_shape), cmap=plt.cm.gray, interpolation='nearest', vmin=-vmax, vmax=vmax) plt.xticks(()) plt.yticks(()) plt.subplots_adjust(0.01, 0.05, 0.99, 0.94, 0.04, 0.) plot_gallery("First centered Olivetti faces", faces[:n_components])############################################################################### estimators = [ ('Eigenfaces - PCA using randomized SVD', decomposition.PCA(n_components=6,whiten=True)), ('Non-negative components - NMF', decomposition.NMF(n_components=6, init='nndsvda', tol=5e-3))] ############################################################################### for name, estimator in estimators: print("Extracting the top %d %s..." % (n_components, name)) print(faces.shape) estimator.fit(faces) components_ = estimator.components_ plot_gallery(name, components_[:n_components]) plt.show() 结果展示]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MOOC机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无监督学习的聚类算法及应用]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[K-means算法原理K-means聚类算法以k为参数，把n个对象分为k个簇，使簇内具有较高的相似度，而簇间的相似度较低。 随机选择k个点作为初始的聚类中心。 对于剩下的点，根据其与聚类中心的距离，将其归入最近的簇。 对每个簇，计算所有点的均值作为新的聚类中心。 重复2、3直到聚类中心不再改变。 K-means算法应用需求通过聚类，了解1999年各个省份的消费水平在国内的情况。 使用算法K-means聚类算法 实现过程 建立工程，导入sklearn相关包 加载数据，创建K-means算法实例，并进行训练，获得标签 输出标签，查看结果 代码1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-"""Created on Thu Apr 18 22:59:44 2019@author: Jiaxi Wang"""import numpy as npfrom sklearn.cluster import KMeans def loadData(filePath): fr = open(filePath,'r+') lines = fr.readlines() retData = [] retCityName = [] for line in lines: items = line.strip().split(",") retCityName.append(items[0]) retData.append([float(items[i]) for i in range(1,len(items))]) return retData,retCityName if __name__ == '__main__': data,cityName = loadData('city.txt') km = KMeans(n_clusters=4) label = km.fit_predict(data) expenses = np.sum(km.cluster_centers_,axis=1) #print(expenses) CityCluster = [[],[],[],[]] for i in range(len(cityName)): CityCluster[label[i]].append(cityName[i]) for i in range(len(CityCluster)): print("Expenses:%.2f" % expenses[i]) print(CityCluster[i]) 结果聚成3类 聚成4类 拓展&amp;改进计算两条数据的相似性时，sklearn的K-means默认使用的时欧氏距离。该算法并没有设定更改距离计算方法的参数。 DBSCAN算法原理DBSCAN算法是一种基于密度的聚类算法： 聚类的时候不需要预先指定簇的个数 最终的簇的个数不定 DBSCAN算法将数据点分为3类： 核心店：在半径Eps内含有超过MinPts数目的点。 边界点：在半径Eps内点的数量少于MinPts，但是落在核心点的邻域内。 噪音点：既不是核心点也不是边界点的点。 DBSCAN密度聚类算法流程 将所有点标记为核心点、边界点或噪声点 删除噪声点 为距离在Eps之内的所有核心点之间赋予一条边 每组连通的核心点形成一个簇 将每个边界点指派到一个与之关联的核心点的簇中（哪一个核心点的半径范围之内） DBSCAN算法应用背景现有某大学校园网的日志数据，290条大学生的校园网使用情况数据，数据包括用户ID，设备MAC地址，IP地址，开始上网时间，停止上网时间，上网时长，校园网套餐等。利用已有数据，分析学生的上网模式。 需求通过DBSCAN聚类，分析学生上网时间和上网时长的模式。 思路 建立工程，引入相关包 加载数据，预处理数据 上网时长的聚类分析、上网时间的聚类分析 分析结果 实现过程 建立工程，导入sklearn相关包 读入数据并进行处理 上网时间/上网时长聚类，创建DBSCAN算法实例，并进行训练，获得标签 输出标签，查看结果 画直方图，分析实验结果 数据分布 vs 聚类 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*-"""Created on Thu Apr 18 23:35:39 2019@author: Jiaxi Wang"""import numpy as npimport sklearn.cluster as skcfrom sklearn import metricsimport matplotlib.pyplot as plt mac2id=dict()onlinetimes=[]f=open('TestData.txt',encoding='utf-8')for line in f: mac=line.split(',')[2] onlinetime=int(line.split(',')[6]) starttime=int(line.split(',')[4].split(' ')[1].split(':')[0]) if mac not in mac2id: mac2id[mac]=len(onlinetimes) onlinetimes.append((starttime,onlinetime)) else: onlinetimes[mac2id[mac]]=[(starttime,onlinetime)]real_X=np.array(onlinetimes).reshape((-1,2)) X=real_X[:,0:1] db=skc.DBSCAN(eps=0.01,min_samples=20).fit(X)labels = db.labels_ print('Labels:')print(labels)raito=len(labels[labels[:] == -1]) / len(labels)print('Noise raito:',format(raito, '.2%')) n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0) print('Estimated number of clusters: %d' % n_clusters_)print("Silhouette Coefficient: %0.3f"% metrics.silhouette_score(X, labels)) for i in range(n_clusters_): print('Cluster ',i,':') print(list(X[labels == i].flatten())) plt.hist(X,24) 结果展示]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MOOC机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵩天老师Python(2)基本图形绘制]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%B5%A9%E5%A4%A9%E8%80%81%E5%B8%88Python(2)%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[深入理解Python语言 Python语言是通用语言 Python语言是脚本语言 Python语言是开源语言 Python语言是跨平台语言 Python语言是多模型语言 实例: Python蟒蛇绘制问题分析 用程序绘制一条蟒蛇 设计蟒蛇的基本形状 实例编写1234567891011121314151617#PythonDraw.pyimport turtleturtle.setup(650, 350, 200, 200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor("purple")turtle.seth(-40)for i in range(4): turtle.circle(40, 80) turtle.circle(-40, 80)turtle.circle(40, 80/2)turtle.fd(40)turtle.circle(16, 180)turtle.fd(40 * 2/3)turtle.done() 图片展示 举一反三 程序参数的改变 Python蟒蛇的颜色：黑色、白色、七彩色… Python蟒蛇的长度：1节、3节、10节… Python蟒蛇的方向：向左走、斜着走… 计算问题的扩展 Python蟒蛇绘制问题是各类图像绘制问题的代表 圆形绘制、五角星绘制、国旗绘制、机器猫绘制… 掌握绘制一条线的方法，就可以绘制整个世界 turtle库的使用turtle库基本介绍turtle(海龟)库是turtle绘图体系的Python实现 turtle绘图体系：1969年诞生，主要用于程序设计入门 Python语言的标准库之一 入门级的图形绘制函数库 标准库Python计算生态 = 标准库 + 第三方库 标准库：随解释器直接安装到操作系统中的功能模块 第三方库：需要经过安装才能使用的功能模块 库Library、包Package、模块Module，统称模块 turtle的原理turtle(海龟)是一种真实的存在 有一只海龟，其实在窗体正中心，在画布上游走 走过的轨迹形成了绘制的图形 海龟由程序控制，可以变换颜色、改变宽度等 turtle绘图窗体1turtle.setup(width, height, startx, starty) setup()设置窗体大小及位置 4个参数中后两个可选 setup()不是必须的 RGB色彩模式 RGB指红蓝绿三个通道的颜色组合 覆盖视力所能感知的所有颜色 RGB每色取值范围0-255整数或0-1小数 常用RGB色彩| 英文名称 | RGB整数值 | RGB小数值 | 中文名称 || ——– | ————- | —————- | ——– || white | 255, 255, 255 | 1, 1, 1 | 白色 || yellow | 255, 255, 0 | 1, 1, 0 | 黄色 || magenta | 255, 0, 255 | 1, 0, 1 | 洋红 || cyan | 0, 255, 255 | 0, 1, 1 | 青色 || blue | 0, 0, 255 | 0, 0, 1 | 蓝色 || black | 0, 0, 0 | 0, 0, 0 | 黑色 || seashell | 255, 245, 238 | 1, 0.96, 0.93 | 海贝色 || gold | 255, 215, 0 | 1, 0.84, 0 | 金色 || pink | 255, 192, 203 | 1, 0.75, 0.80 | 粉红色 || brown | 165, 42, 42 | 0.65, 0.16, 0.16 | 棕色 || purple | 160, 32, 240 | 0.63, 0.13, 0.94 | 紫色 || tomato | 255, 99, 71 | 1, 0.39, 0.28 | 番茄色 | 1turtle.colormode(mode) turtle程序语法元素分析库引用与import库引用扩充Python程序功能的方式,使用import保留字完成，采用.()编码风格 12import &lt;库名&gt; &lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;) import更多用法 使用from和import保留字共同完成 123from &lt;库名&gt; import &lt;函数名&gt; from &lt;库名&gt; import *&lt;函数名&gt;(&lt;函数参数&gt;) 使用import和as保留字共同完成 12import &lt;库名&gt; as &lt;库别名&gt; &lt;库别名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;) turtle画笔控制函数 turtle.penup() 别名 turtle.pu()抬起画笔，海龟在飞行 turtle.pendown() 别名 turtle.pd()落下画笔，海龟在爬行 turtle.pensize(width) 别名 turtle.width(width)画笔宽度，海龟的腰围 turtle.pencolor(color) color为颜色字符串或r,g,b值画笔颜色，海龟在涂装 颜色字符串 ：turtle.pencolor(&quot;purple&quot;) RGB的小数值：turtle.pencolor(0.63, 0.13, 0.94) RGB的元组值：turtle.pencolor((0.63,0.13,0.94)) turtle运动控制函数 turtle.forward(d) 别名 turtle.fd(d)向前行进，海龟走直线 d: 行进距离，可以为负数 turtle.circle(r, extent=None)根据半径r绘制extent角度的弧形 r: 默认圆心在海龟左侧r距离的位置 extent: 绘制角度，默认是360度整圆 turtle方向控制函数 turtle.setheading(angle) 别名 turtle.seth(angle)改变行进方向，海龟走角度 angle: 行进方向的绝对角度 turtle.left(angle) 海龟向左转 turtle.right(angle) 海龟向右转 angle: 在海龟当前行进方向上旋转的角度 循环语句与range()函数循环语句按照一定次数循环执行一组语句 1234for &lt;变量&gt; in range(&lt;次数&gt;): &lt;被循环执行的语句&gt;# &lt;变量&gt;表示每次循环的计数，0到&lt;次数&gt;-1 range()函数产生循环计数序列 range(N)产生 0 到 N-1的整数序列，共N个 range(M,N)产生 M 到 N-1的整数序列，共N-M个]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现照片的手绘效果]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E5%AE%9E%E7%8E%B0%E7%85%A7%E7%89%87%E7%9A%84%E6%89%8B%E7%BB%98%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[梯度的重构利用像素之间的梯度值和虚拟深度值对图像进行重构，根据灰度变化来模拟人类视觉的明暗程度。 手绘效果的特征 黑白灰色 边界线条较重 相同或相近色彩趋于白色 略有光源效果 代码实现用到的第三方库安装：1pip install pillow,numpy 1234567891011121314151617181920212223242526272829#image.pyfrom PIL import Imageimport numpy as npa = np.asarray(Image.open('./yunwuyue.jpg').convert('L')).astype('float')depth = 10. #预设深度值为10，取值范围0-100grad = np.gradient(a) #提取x和y方向的梯度值grad_x, grad_y = grad#根据深度值调整x和y方向的梯度值grad_x = grad_x * depth / 100.grad_y = grad_y * depth / 100.A = np.sqrt(grad_x**2 + grad_y**2 + 1.)uni_x = grad_x / Auni_y = grad_y / Auni_z = 1. / Avec_el = np.pi / 2.2vec_az = np.pi / 4dx = np.cos(vec_el) * np.cos(vec_az)dy = np.cos(vec_el) * np.sin(vec_az)dz = np.sin(vec_el)b = 255 * (dx * uni_x + dy * uni_y + dz * uni_z)b = b.clip(0, 255)im = Image.fromarray(b.astype('uint8'))im.save('./yunwuyueHD.jpg') 展示]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib绘制引力波]]></title>
    <url>%2F2019%2F04%2F04%2FMatplotlib%E7%BB%98%E5%88%B6%E5%BC%95%E5%8A%9B%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[2016年6月16日，LIGO合作组宣布2015年12月26日 03:38:53（UTC），两台不同位置的引力波探测器同时探测到了一个引力波信号。 引力波物理学中，引力波是因为时空弯曲对外以辐射形式传播的能量。爱因斯坦基于广义相对论语言了引力波的存在。2016年6月16日，LIGO合作组宣布2015年12月26日 03:38:53（UTC），两台不同位置的引力波探测器同时探测到了一个引力波信号。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-"""Created on Sun Feb 24 10:17:31 2019@author: Administrator"""#引力波import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile#产生时间序列rate_h, hstrain = wavfile.read(r"H1_Strain.wav","rb")rate_l, lstrain = wavfile.read(r"L1_Strain.wav","rb")reftime, ref_H1 = np.genfromtxt('wf_template.txt').transpose()#读取应变数据htime_interval = 1 / rate_hltime_interval = 1 / rate_lhtime_len = hstrain.shape[0] / rate_hhtime = np.arange(-htime_len / 2, htime_len / 2, htime_interval)ltime_len = lstrain.shape[0] / rate_lltime = np.arange(-ltime_len / 2, ltime_len / 2, ltime_interval)#使用来自“H1”探测器的数据作图fig = plt.figure(figsize = (12, 6)) #创建一个12*6的绘图空间plth = fig.add_subplot(221)plth.plot(htime, hstrain, 'y')plth.set_xlabel('Time(seconds)')plth.set_ylabel('H1 Strain')plth.set_title('H1 Strain')#绘制L1 Strain 和 Templatepltl = fig.add_subplot(222)pltl.plot(ltime, lstrain, 'g')pltl.set_xlabel('Time(seconds)')pltl.set_ylabel('L1 Strain')pltl.set_title('L1 Strain')pltref = fig.add_subplot(212)pltref.plot(reftime, ref_H1, 'y')pltref.set_xlabel('Time(seconds)')pltref.set_ylabel('Template Strain')pltref.set_title('Template')#自动调整图像外部边缘fig.tight_layout()plt.savefig("Gravitational_Waves_Original.png")plt.show()plt.close(fig) 图像展示 数据源http://python123.io/dv/grawave.html http://python123.io/dv/H1_Strain.wavhttp://python123.io/dv/L1_Strain.wavhttp://python123.io/dv/wf_template.txt]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据集群搭建]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用虚拟机搭建集群时的必要工作。 修改网卡 关闭防火墙 修改主机名、映射关系 安装JDK，配置环境变量 时间同步、集群通信、免密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#修改网卡信息vi /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0TYPE=EthernetUUID=81c06473-0e58-4a5a-b4c4-35a2a853ab04ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.8.100NETMASK=255.255.255.0GATEWAY=192.168.8.1DNS1=192.168.8.1DNS2=114.114.114.114#重启生效service network restart#++++++++++++++++++++++++++++++++++++++++++++++++#关闭防火墙 service iptables stop chkconfig iptables off #++++++++++++++++++++++++++++++++++++++++++++++++#修改主机名 vi /etc/sysconfig/network #++++++++++++++++++++++++++++++++++++++++++++++++#修改映射关系 vi /etc/hosts #++++++++++++++++++++++++++++++++++++++++++++++++#环境变量 vi /etc/profile export JAVA_HOME=/root/app/jdk1.8.0_191 export PATH=$PATH:$JAVA_HOME/bin #source一下生效 source /etc/profile #++++++++++++++++++++++++++++++++++++++++++++++++#时间同步yum install ntpdate -yntpdate 0.asia.pool.ntp.org#++++++++++++++++++++++++++++++++++++++++++++++++#集群通信yum install openssh-clientsssh登陆，scp发送文件scp -r /etc/hosts bigdata-03:/etc/#免密登陆ssh-keygen -t rsa #生成公钥和私钥ssh-copy-id -i /root/.ssh/id_rsa.pub bigdata-03 #为需要进行免密的机器进行发送公钥（不要忘了给自己发）#++++++++++++++++++++++++++++++++++++++++++++++++]]></content>
      <categories>
        <category>大数据开发</category>
      </categories>
      <tags>
        <tag>大数据开发</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式消息发布订阅系统Kafka]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9FKafka%2F</url>
    <content type="text"><![CDATA[Kafka概述 和消息系统类似 消息中间件：生产者和消费者 A distributed streaming platform Kafka架构和核心概念 Kafka is run as a cluster on one or more servers that can span multiple datacenters. The Kafka cluster stores streams of records in categories called topics. Each record consists of a key, a value, and a timestamp. 单节点单broker的Kafka部署及使用1234567# $KAFKA_HOME/config/server.propertiesbroker.id=0listeners=PLAINTEXT://:9092host.name=bigdata-01log.dirs=/root/app/tmp/kafka-logszookeeper.connect=bigdata-01:2181 启动kafka123bin/kafka-server-start.sh $KAFKA_HOME/config/server.propertiesUSAGE: /root/app/kafka_2.11-0.9.0.0/bin/kafka-server-start.sh [-daemon] server.properties [--override property=value]* 创建topic：zk1bin/kafka-topics.sh --create --zookeeper bigdata-01:2181 --replication-factor 1 --partitions 1 --topic hello_topic 查看所有topic1bin/kafka-topics.sh --list --zookeeper bigdata-01:2181 发送消息：broker1bin/kafka-console-producer.sh --broker-list bigdata-01:9092 --topic hello_topic 消费消息：zk1bin/kafka-console-consumer.sh --zookeeper bigdata-01:2181 -topic hello_topic 查看所有topic的详细信息：1kafka-topics.sh --describe --zookeeper bigdata-01:2181 查看指定topic的详细信息：1kafka-topics.sh --describe --zookeeper bigdata-01:2181 -topic hello_topic 单节点多broker的Kafka部署及使用123456789101112131415161718#配置多个配置文件server-1.propertiesserver-2.propertiesserver-3.properties#启动kafka-server-start.sh -daemon $KAFKA_HOME/config/server-1.properties &amp;kafka-server-start.sh -daemon $KAFKA_HOME/config/server-2.properties &amp;kafka-server-start.sh -daemon $KAFKA_HOME/config/server-3.properties &amp;#创建topicbin/kafka-topics.sh --create --zookeeper bigdata-01:2181 --replication-factor 3 --partitions 1 --topic my-replication-topic#启动一个生产者kafka-console-producer.sh --broker-list bigdata-01:9093,bigdata-01:9094，bigdata-01:9095 --topic my-replication-topic#启动一个消费者kafka-console-consumer.sh --zookeeper bigdata-01:2181 -topic my-replication-topic Kafka容错性测试12345[root@bigdata-01 ~]# kafka-topics.sh --describe --zookeeper bigdata-01:2181Topic:hello_topic PartitionCount:1 ReplicationFactor:1 Configs: Topic: hello_topic Partition: 0 Leader: 0 Replicas: 0 Isr: 0Topic:my-replication-topic PartitionCount:1 ReplicationFactor:3 Configs: Topic: my-replication-topic Partition: 0 Leader: 3 Replicas: 3,1,2 Isr: 3,1,2 此时leader为broker3，如果终止该进程，会发生什么呢？123456789101112131415[root@bigdata-01 ~]# jps -m2882 ConsoleConsumer --zookeeper bigdata-01:2181 -topic my-replication-topic2660 Kafka /root/app/kafka_2.11-0.9.0.0/config/server-3.properties2550 Kafka /root/app/kafka_2.11-0.9.0.0/config/server-1.properties2843 ConsoleProducer --broker-list bigdata-01:9093,bigdata-01:9094，bigdata-01:9095 --topic my-replication-topic2955 Jps -m1934 QuorumPeerMain /root/app/zookeeper-3.4.5-cdh5.7.0/bin/../conf/zoo.cfg[root@bigdata-01 ~]# kill -9 2550[root@bigdata-01 ~]# kill -9 2660[root@bigdata-01 ~]# kafka-topics.sh --describe --zookeeper bigdata-01:2181Topic:hello_topic PartitionCount:1 ReplicationFactor:1 Configs: Topic: hello_topic Partition: 0 Leader: 0 Replicas: 0 Isr: 0Topic:my-replication-topic PartitionCount:1 ReplicationFactor:3 Configs: Topic: my-replication-topic Partition: 0 Leader: 2 Replicas: 3,1,2 Isr: 2 发现杀掉broker1,3以后，选举2为leader，并不影响消息的发送和接收。 Kafka的Java API使用IDEA + Maven构建开发环境，pom.xml配置如下12345678910111213141516171819&lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;kafka.version&gt;0.9.0.0&lt;/kafka.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--kafka dependency--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;kafka.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 创建Kafka的配置类123456789/** * Kafka常用配置文件 */public class KafkaProperties &#123; public static final String ZK = "bigdata-01:2181"; public static final String TOPIC = "hello_topic"; public static final String BROKER_LIST = "bigdata-01:9092"; public static final String GROUP_ID = "test_group_1";&#125; Kafka的生产者12345678910111213141516171819202122232425262728293031323334353637import kafka.javaapi.producer.Producer;import kafka.producer.KeyedMessage;import kafka.producer.ProducerConfig;import java.util.Properties;/** * Kafka生产者 */public class KafkaProducer extends Thread&#123; private String topic; private Producer&lt;Integer,String&gt; producer; public KafkaProducer(String topic)&#123; this.topic = topic; Properties properties = new Properties(); properties.put("metadata.broker.list",KafkaProperties.BROKER_LIST); properties.put("serializer.class","kafka.serializer.StringEncoder"); properties.put("request.required.acks","1"); producer = new Producer&lt;Integer, String&gt;(new ProducerConfig(properties)); &#125; @Override public void run() &#123; int messageNo = 1; while (true)&#123; String message = "message_" + messageNo; producer.send(new KeyedMessage&lt;Integer, String&gt;(topic, message)); System.out.println("Sent: " + message); messageNo ++ ; try&#123; Thread.sleep(2000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Kafka的消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445import kafka.consumer.Consumer;import kafka.consumer.ConsumerConfig;import kafka.consumer.ConsumerIterator;import kafka.consumer.KafkaStream;import kafka.javaapi.consumer.ConsumerConnector;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Properties;import static com.wjx.spark.kafka.KafkaProperties.GROUP_ID;/** * Kafka消费者 */public class KafkaConsumer extends Thread&#123; private String topic; public KafkaConsumer(String topic)&#123; this.topic = topic; &#125; private ConsumerConnector createConnector()&#123; Properties properties = new Properties(); properties.put("zookeeper.connect",KafkaProperties.ZK); properties.put("group.id",KafkaProperties.GROUP_ID); return Consumer.createJavaConsumerConnector(new ConsumerConfig(properties)); &#125; @Override public void run() &#123; ConsumerConnector consumer = createConnector(); Map&lt;String,Integer&gt; topicCountMap = new HashMap&lt;String, Integer&gt;(); topicCountMap.put(topic, 1); //String:topic //List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt; 对应的数据流 Map&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt;&gt; messageStreams = consumer.createMessageStreams(topicCountMap); KafkaStream&lt;byte[], byte[]&gt; stream = messageStreams.get(topic).get(0);//获取每次接收到的数据 ConsumerIterator&lt;byte[], byte[]&gt; iterator = stream.iterator(); while (iterator.hasNext())&#123; String message = new String(iterator.next().message()); System.out.println("received: " + message); &#125; &#125;&#125; Kafka客户端启动测试123456789/** * Kafka Java API测试 */public class KafkaClientApp &#123; public static void main(String[] args) &#123; new KafkaProducer(KafkaProperties.TOPIC).start(); new KafkaConsumer(KafkaProperties.TOPIC).start(); &#125;&#125;]]></content>
      <categories>
        <category>大数据开发</category>
      </categories>
      <tags>
        <tag>大数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式日志采集框架Flume]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E6%A1%86%E6%9E%B6Flume%2F</url>
    <content type="text"><![CDATA[Flume概述Flume is a distributed, reliable, and available service for efficiently collecting(收集), aggregating(聚合), and moving(移动) large amounts of log data. Flume官网：http://flume.apache.org/ FLume是一个分布式、高可靠、高可用的服务，用于分布式海量日志高效收集、聚合、移动系统。 设计目标 可靠性 扩展性 管理性 业界同类产品对比 Flume: Cloudera/Apache Java Scribe: Facebook C/C++ 不再维护 Chukwa: Yahoo/Apache Java 不再维护 Fluentd: Ruby Logstash: ELK(Elasticsearch,Kibana) Flume架构及核心组件 Source 收集 Channel 聚集 Sink 输出 Flume环境部署前置条件 Java Runtime Environment - Java 1.8 or later Memory - Sufficient memory for configurations used by sources, channels or sinks Disk Space - Sufficient disk space for configurations used by channels or sinks Directory Permissions - Read/Write permissions for directories used by agent 安装jdk下载解压到~/app将java配置到系统环境变量中：vi ~/.bash_profile123export JAVA_HOME=/root/app/jdk1.8.0_191export PATH=$JAVA_HOME/bin:$PATHsource ~/.bash_profile 检测：java -version 安装Flume下载解压到~/app将flume配置到系统环境变量中：123export FLUME_HOME=/root/app/apache-flume-1.6.0-cdh5.7.0-binexport PATH=$FLUME_HOME/bin:$PATHsource ~/.bash_profile flume-env.sh的配置：export JAVA_HOME=/root/app/jdk1.8.0_191检测：flume-ng version Flume实战需求1：从指定网络端口采集数据输出到控制台使用flume的关键就是写配置文件： 配置source 配置channel 配置sink 把以上3个组件串起来 配置文件1234567891011121314151617181920212223242526272829# example.conf: A single-node Flume configuration# a1:agent名称# r1:source名称# k1:sink名称# c1:channel名称# Name the components on this agenta1.sources = r1a1.sinks = k1a1.channels = c1# Describe/configure the sourcea1.sources.r1.type = netcata1.sources.r1.bind = localhosta1.sources.r1.port = 44444# Describe the sinka1.sinks.k1.type = logger# Use a channel which buffers events in memorya1.channels.c1.type = memory# a1.channels.c1.capacity = 1000# a1.channels.c1.transactionCapacity = 100# Bind the source and sink to the channela1.sources.r1.channels = c1a1.sinks.k1.channel = c1 启动agent12345flume-ng agent \--name a1 \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/example.conf \-Dflume.root.logger=INFO,console 使用telnet进行测试：telnet localhost 444441Event: &#123; headers:&#123;&#125; body: 68 65 6C 6C 6F 0D hello. &#125; Event是Flume数据传输的基本单元Event = 可选的header + byte array 需求2：监控一个文件实时采集新增的数据输出到控制台Agent选型：exec source + memory channel + logger sink 配置文件123456789101112131415161718192021222324# example.conf: A single-node Flume configuration# Name the components on this agenta1.sources = r1a1.sinks = k1a1.channels = c1# Describe/configure the sourcea1.sources.r1.type = execa1.sources.r1.command = tail -F /root/data/data.loga1.sources.r1.shell = /bin/bash -c# Describe the sinka1.sinks.k1.type = logger# Use a channel which buffers events in memorya1.channels.c1.type = memory# a1.channels.c1.capacity = 1000# a1.channels.c1.transactionCapacity = 100# Bind the source and sink to the channela1.sources.r1.channels = c1a1.sinks.k1.channel = c1 启动agent12345flume-ng agent \--name a1 \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/exec-memory-logger.conf \-Dflume.root.logger=INFO,console 需求3：将A服务器上的日志实时采集到B服务器技术选型：exec source + memory channel + avro sink avro source + memory channel + logger sink 配置文件1:exec-memory-avro.conf12345678910111213141516exec-memory-avro.sources = exec-sourceexec-memory-avro.sinks = avro-sinkexec-memory-avro.channels = memory-channelexec-memory-avro.sources.exec-source.type = execexec-memory-avro.sources.exec-source.command = tail -F /root/data/data.logexec-memory-avro.sources.exec-source.shell = /bin/bash -cexec-memory-avro.sinks.avro-sink.type = avroexec-memory-avro.sinks.avro-sink.hostname = bigdata-01exec-memory-avro.sinks.avro-sink.port = 44444exec-memory-avro.channels.memory-channel.type = memoryexec-memory-avro.sources.exec-source.channels = memory-channelexec-memory-avro.sinks.avro-sink.channel = memory-channel 配置文件2:avro-memory-logger.conf1234567891011121314avro-memory-logger.sources = avro-sourceavro-memory-logger.sinks = logger-sinkavro-memory-logger.channels = memory-channelavro-memory-logger.sources.avro-source.type = avroavro-memory-logger.sources.avro-source.bind = bigdata-01avro-memory-logger.sources.avro-source.port = 44444avro-memory-logger.sinks.logger-sink.type = loggeravro-memory-logger.channels.memory-channel.type = memoryavro-memory-logger.sources.avro-source.channels = memory-channelavro-memory-logger.sinks.logger-sink.channel = memory-channel 先启动avro-memory-logger12345flume-ng agent \--name avro-memory-logger \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/avro-memory-logger.conf \-Dflume.root.logger=INFO,console 再启动exec-memory-avro12345flume-ng agent \--name exec-memory-avro \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/exec-memory-avro.conf \-Dflume.root.logger=INFO,console 日志收集过程： 机器A上监控一个文件，当我们访问主站的时候，会有用户行为日志记录到access.log中 avro sink 把新产生的日志输出到对应的 avro source 指定的 hostname 和 port 上 通过 avro source 对应的 agent 将我们的日志输出到控制台(kafka)]]></content>
      <categories>
        <category>大数据开发</category>
      </categories>
      <tags>
        <tag>大数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础语句复习]]></title>
    <url>%2F2019%2F04%2F04%2FSQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一些最重要的 SQL 命令不能忘 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT DISTINCT（选择不同） 语法SELECT DISTINCT语法用于仅返回不同的（different）值。在一张表内，一列通常包含许多重复的值; 有时你只想列出不同的（different）值。SELECT DISTINCT语句用于仅返回不同的（different）值。 12345678SELECT DISTINCT column1, column2, ...FROM table_name;/*实例*/SELECT DISTINCT Country FROM Customers;/*列出不同（distinct）客户国家的数量*/SELECT COUNT(DISTINCT Country) FROM Customers; SQL WHERE 语法1234567SELECT column1, column2, ...FROM table_nameWHERE condition;/*实例*/SELECT * FROM CustomersWHERE Country='Mexico'; WHERE子句中可以使用以下运算符： 运算符 描述 = 等于 &lt;&gt; 不等于。注意：在某些版本的SQL中，这个操作符可能写成!= > 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 为列指定多个可能的值 SQL AND &amp; OR 运算符WHERE子句可以与AND，OR和NOT运算符结合使用。 AND和OR运算符用于根据多个条件筛选记录： 如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。 如果由OR分隔的任何条件为真，则OR运算符显示记录。 如果条件不为真，则NOT运算符显示记录。 12345678910111213141516/*实例*/SELECT * FROM Customers WHERE Country='Germany' AND City='Berlin';SELECT * FROM CustomersWHERE City='Berlin' OR City='München';SELECT * FROM CustomersWHERE NOT Country='Germany';SELECT * FROM CustomersWHERE Country='Germany' AND (City='Berlin' OR City='München');SELECT * FROM CustomersWHERE NOT Country='Germany' AND NOT Country='USA'; SQL ORDER BY Keyword（按关键字排序）SQL ORDER BY 关键字 ORDER BY 关键字用于按升序或降序对结果集进行排序。ORDER BY 关键字默认情况下按升序排序记录。如果需要按降序对记录进行排序，可以使用DESC关键字。 1234567891011121314SELECT column1, column2, ...FROM table_nameORDER BY column1, column2, ... ASC|DESC;/*ORDER BY 多列 实例*//*从 "Customers" 表中选取所有客户，并按照 "Country" 和 "CustomerName" 列排序*/SELECT * FROM CustomersORDER BY Country, CustomerName;/*从"Customers" 表中选择所有客户，按 "Country" 升序排列，并按 "CustomerName" 列降序排列*/SELECT * FROM CustomersORDER BY Country ASC, CustomerName DESC; SQL INSERT INTO 语句（在表中插入）SQL INSERT INTO 语句 INSERT INTO 语句用于向表中插入新记录。 SQL INSERT INTO 语法 INSERT INTO 语句可以用两种形式编写。第一个表单没有指定要插入数据的列的名称，只提供要插入的值：123456789INSERT INTO table_name (column1, column2, column3, ...)VALUES (value1, value2, value3, ...);/*实例*/INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)VALUES ('Cardinal','Tom B. Erichsen','Skagen 21','Stavanger','4006','Norway');INSERT INTO Customers (CustomerName, City, Country)VALUES ('Cardinal', 'Stavanger', 'Norway'); 如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。123456INSERT INTO table_nameVALUES (value1, value2, value3, ...);/*实例*/INSERT INTO Customers VALUES ('Cardinal','Tom B. Erichsen','Skagen 21','Stavanger','4006','Norway'); SQL NULL Values（空值）如何测试NULL值？ 使用比较运算符（例如=，&lt;或&lt;&gt;）来测试NULL值是不可行的。我们将不得不使用IS NULL和IS NOT NULL运算符。 123456789/*IS NULL语法*/SELECT column_namesFROM table_nameWHERE column_name IS NULL;/*IS NOT NULL语法*/SELECT column_namesFROM table_nameWHERE column_name IS NOT NULL; SQL UPDATE 语句（更新表中的记录）UPDATE 语句用于更新表中已存在的记录。 1234567891011/*SQL UPDATE 语法*/UPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;/*实例*//*把国家/地区为"Mexico"的所有记录的联系人姓名更新为“Juan”*/UPDATE CustomersSET ContactName='Juan'WHERE Country='Mexico'; 更新记录时要小心。如果省略WHERE子句，所有记录将被更新！12UPDATE CustomersSET ContactName='Juan'; SQL Delete 语句（删除表中的记录）DELETE 语句用于删除表中的行。 1234/*SQL DELETE 语法*/DELETE FROM table_nameWHERE condition; WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！ 删除所有数据：可以删除表中的所有行，而不需要删除该表。这意味着表的结构、属性和索引将保持不变123DELETE FROM table_name;/*或者*/DELETE * FROM table_name;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis操作]]></title>
    <url>%2F2019%2F04%2F04%2FRedis%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[环境准备：centOS6.5Redis是c语言开发的。安装redis需要c语言的编译环境。如果没有gcc需要在线安装。 安装编译环境yum install gcc-c++ 安装步骤 第一步：redis的源码(安装)包上传到linux系统。 第二步：进入到压缩包所在的路径，解压缩redis。 1tar -zxvf redis-3.0.0.tar.gz 第三步：编译。进入redis源码目录（redis3.0.0）。 执行：make 第四步：进入/usr/redis-3.0.0/src/安装。 1make install PREFIX=/usr/java/redis 如果报错123456zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directoryzmalloc.h:55:2: error: #error "Newer version of jemalloc required"make[1]: *** [adlist.o] Error 1make[1]: Leaving directory `/data0/src/redis-2.6.2/src'make: *** [all] Error 2 解决办法是：1make MALLOC=libc PREFIX参数指定redis的安装目录。一般软件安装到/usr目录下 连接redis redis的启动前端启动在redis的安装目录的bin目录下直接启动redis-server 1./redis-server 后台启动把/root/redis-3.0.0/redis.conf复制到/usr/java/redis/bin目录下 1cp redis.conf /usr/java/redis/bin/ 修改配置文件： 启动服务器： 1./redis-server redis.conf 查看redis进程： 1ps aux|grep redis 12root 5190 0.1 0.3 33936 1712 ? Ssl 18:23 0:00 ./redis-server *:6379 root 5196 0.0 0.1 4356 728 pts/0 S+ 18:24 0:00 grep redis 关闭服务1./redis-cli shutdown 或者通过kill -9 PID关闭 Redis-cli [root@localhost bin]# ./redis-cli 默认连接localhost运行在6379端口的redis服务。 [root@localhost bin]# ./redis-cli -h 192.168.75.128 -p 6379 -h：连接的服务器的地址 -p：服务的端口号 关闭redis：1./redis-cli shutdown]]></content>
      <categories>
        <category>大数据开发</category>
      </categories>
      <tags>
        <tag>大数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之Numpy库入门]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy%E5%BA%93%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[数据的维度一个数据表达一个含义一组数据表达一个或多个含义 一维数据一维数据由对等关系的有序或无序数据构成，采用线性方式组织，对应列表、数组和集合等概念。 列表和数组 列表：数据类型可以不同 数组：数据类型相同 二维数据二维数据由多个一维数据构成，是一维数据的组合形式。表格是典型的二维数据，其中，表头是二维数据的一部分。 多维数据多维数据由一维或二维数据在新维度上扩展形成。 高维数据高维数据仅利用最基本的二元关系展示数据间的复杂结构。12345678910&#123; “firstName” : “Tian” , “lastName” : “Song” , “address” : &#123; “streetAddr” : “中关村南大街5号” , “city” : “北京市” , “zipcode” : “100081” &#125; , “prof” : [ “Computer System” , “Security” ]&#125; 数据维度的Python表示数据维度是数据的组织形式。 一维数据：列表和集合类型 二维数据：列表类型 多维数据：列表类型 高维数据：字典类型或数据表示格式(JSON、XML和YAML格式) NumPy的数组对象：ndarrayNumPyNumPy是一个开源的Python科学计算基础库，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合C/C++/Fortran代码的工具 线性代数、傅里叶变换、随机数生成等功能NumPy是SciPy、Pandas等数据处理或科学计算库的基础。 NumPy的引用尽管别名可以省略或更改，建议使用上述约定的别名 N维数组对象：ndarrayPython已有列表类型，为什么需要一个数组对象(类型)？ 数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数 设置专门的数组对象，经过优化，可以提升这类应用的运算速度 观察：科学计算中，一个维度所有数据的类型往往相同 数组对象采用相同的数据类型，有助于节省运算和存储 ndarray是一个多维数组对象，由两部分构成： 实际的数据 描述这些数据的元数据（数据维度、数据类型等）ndarray数组一般要求所有元素类型相同（同质），数组下标从0开始 ndarray实例123np.array() #生成一个ndarray数组#np.array()输出成[]形式，元素由空格分割#轴(axis): 保存数据的维度；秩(rank)：轴的数量 ndarray对象的属性 属性 说明 .ndim 秩，即轴的数量或维度的数量 .shape ndarray对象的尺度，对于矩阵，n行m列 .size ndarray对象元素的个数，相当于.shape中n*m的值 .dtype ndarray对象的元素类型 .itemsize ndarray对象中每个元素的大小，以字节为单位 ndarray数组的元素ndarray的元素类型(1) 数据类型 说明 bool 布尔类型，True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数，与C语言中ssize_t一致，int32或int64 int8 字节长度的整数，取值：[‐128, 127] int16 16位长度的整数，取值：[‐32768, 32767] int32 32位长度的整数，取值：[‐2^31,2^31‐1] int64 64位长度的整数，取值：[‐2^63,2^63‐1] ndarray的元素类型(2) 数据类型 说明 uint8 8位无符号整数，取值：[0, 255] uint16 16位无符号整数，取值：[0, 65535] uint32 32位无符号整数，取值：[0,232‐1] uint6 32位无符号整数，取值：[0,264‐1] float16 16位半精度浮点数：1位符号位，5位指数，10位尾数 float32 32位半精度浮点数：1位符号位，8位指数，23位尾数 float64 64位半精度浮点数：1位符号位，11位指数，52位尾数 ndarray的元素类型(3) 数据类型 说明 complex64 复数类型，实部和虚部都是32位浮点数 complex128 复数类型，实部和虚部都是64位浮点数 ndarray为什么要支持这么多种元素类型？ 对比：Python语法仅支持整数、浮点数和复数3种类型 科学计算涉及数据较多，对存储和性能都有较高要求 对元素类型精细定义，有助于NumPy合理使用存储空间并优化性能 对元素类型精细定义，有助于程序员对程序规模有合理评估 非同质的ndarray对象 ndarray数组可以由非同质对象构成 非同质ndarray元素为对象类型 非同质ndarray对象无法有效发挥NumPy优势，尽量避免 ndarray数组的创建ndarray数组的创建方法 从Python中的列表、元组等类型创建ndarray数组 使用NumPy中函数创建ndarray数组，如：arange, ones, zero （1）从Python中的列表、元组等类型创建ndarray数组123x= np.array(list/tuple)x= np.array(list/tuple, dtype=np.float32)#当np.array()不指定dtype时，NumPy将根据数据情况关联一个dtype 12345678#从列表类型创建x = np.array([0, 1, 2, 3])#从元组类型创建x = np.array((4, 5, 6, 7))#从列表和元组混合类型创建x = np.array([[1, 2], [9, 8], (0.1, 0.2)]) （2）使用NumPy中函数创建ndarray数组，如：arange, ones, zero等 函数 说明 np.arange(n) 类似range()函数，返回ndarray类型，元素从0到n‐1 np.ones(shape) 根据shape生成一个全1数组，shape是元组类型 np.zeros(shape) 根据shape生成一个全0数组，shape是元组类型 np.full(shape,val) 根据shape生成一个数组，每个元素值都是valnp.eye(n)创建一个正方的n*n单位矩阵，对角线为1，其余为0 np.ones_like(a) 根据数组a的形状生成一个全1数组 np.zeros_like(a) 根据数组a的形状生成一个全0数组 np.full_like(a,val) 根据数组a的形状生成一个数组，每个元素值都是val （3）使用NumPy中其他函数创建ndarray数组 函数 说明 np.linspace() 根据起止数据等间距地填充数据，形成数组 np.concatenate() 将两个或多个数组合并成一个新的 ndarray数组的变换对于创建后的ndarray数组，可以对其进行维度变换和元素类型变换 ndarray数组的维度变换 方法 说明 .reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 .resize(shape) 与.reshape()功能一致，但修改原数组 .swapaxes(ax1,ax2) 将数组n个维度中两个维度进行调换 .flatten() 对数组进行降维，返回折叠后的一维数组，原数组不变 ndarray数组的类型变换1new_a = a.astype(new_type) astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致。 ndarray数组向列表的转换1ls = a.tolist() ndarray数组的操作数组的索引和切片 索引：获取数组中特定位置元素的过程 切片：获取数组元素子集的过程 一维数组的索引和切片123456789In [7]: a = np.array([9,8,7,6,5])In [8]: a[2]Out[8]: 7#起始编号: 终止编号(不含): 步长，3元素冒号分割#编号0开始从左递增，或‐1开始从右递减In [9]: a[1:4:2]Out[9]: array([8, 6]) 多维数组的索引和切片多维数组的索引：每个维度一个索引值，逗号分割 1234567891011121314151617181920In [10]: a = np.arange(24).reshape((2,3,4))In [11]: aOut[11]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])In [12]: a[1,2,3]Out[12]: 23In [13]: a[0,1,2]Out[13]: 6In [14]: a[-1,-2,-3]Out[14]: 17 多维数组的切片： 选取一个维度用”:”,每个维度切片方法与一维数组相同,每个维度可以使用步长跳跃切片。 12345678910111213141516171819202122#In [10]: a = np.arange(24).reshape((2,3,4))In [15]: a[:,1,-3]Out[15]: array([ 5, 17])In [16]: a[:,1:3,:]Out[16]: array([[[ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[16, 17, 18, 19], [20, 21, 22, 23]]])In [17]: a[:,:,::2]Out[17]: array([[[ 0, 2], [ 4, 6], [ 8, 10]], [[12, 14], [16, 18], [20, 22]]]) ndarray数组的运算数组与标量之间的运算数组与标量之间的运算作用于数组的每一个元素 1234567891011121314151617181920212223242526In [19]: a = np.arange(24).reshape((2,3,4))In [20]: aOut[20]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])In [21]: a.mean()Out[21]: 11.5In [22]: a = a / a.mean()In [23]: aOut[23]: array([[[0. , 0.08695652, 0.17391304, 0.26086957], [0.34782609, 0.43478261, 0.52173913, 0.60869565], [0.69565217, 0.7826087 , 0.86956522, 0.95652174]], [[1.04347826, 1.13043478, 1.2173913 , 1.30434783], [1.39130435, 1.47826087, 1.56521739, 1.65217391], [1.73913043, 1.82608696, 1.91304348, 2. ]]]) NumPy一元函数对ndarray中的数据执行元素级运算的函数 函数 说明 np.abs(x) np.fabs(x) 计算数组各元素的绝对值 np.sqrt(x) 计算数组各元素的平方根 np.square(x) 计算数组各元素的平方 np.log(x) np.log10(x) np.log2(x) 计算数组各元素的自然对数、10底对数和2底对数 np.ceil(x) np.floor(x) 计算数组各元素的ceiling值 或 floor值 np.rint(x) 计算数组各元素的四舍五入值 np.modf(x) 将数组各元素的小数和整数部分以两个独立数组形式返回 np.cos(x) np.cosh(x) np.sin(x) np.sinh(x) np.tan(x) np.tanh(x) 计算数组各元素的普通型和双曲型三角函数 np.exp(x) 计算数组各元素的指数值 np.sign(x) 计算数组各元素的符号值，1(+), 0,-1(-) 12345678910111213141516171819202122232425262728293031323334353637383940In [24]: a = np.arange(24).reshape((2,3,4))In [25]: np.square(a)Out[25]: array([[[ 0, 1, 4, 9], [ 16, 25, 36, 49], [ 64, 81, 100, 121]], [[144, 169, 196, 225], [256, 289, 324, 361], [400, 441, 484, 529]]], dtype=int32)In [26]: a = np.sqrt(a)In [27]: aOut[27]: array([[[0. , 1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974, 2.64575131], [2.82842712, 3. , 3.16227766, 3.31662479]], [[3.46410162, 3.60555128, 3.74165739, 3.87298335], [4. , 4.12310563, 4.24264069, 4.35889894], [4.47213595, 4.58257569, 4.69041576, 4.79583152]]])In [28]: np.modf(a)Out[28]: (array([[[0. , 0. , 0.41421356, 0.73205081], [0. , 0.23606798, 0.44948974, 0.64575131], [0.82842712, 0. , 0.16227766, 0.31662479]], [[0.46410162, 0.60555128, 0.74165739, 0.87298335], [0. , 0.12310563, 0.24264069, 0.35889894], [0.47213595, 0.58257569, 0.69041576, 0.79583152]]]), array([[[0., 1., 1., 1.], [2., 2., 2., 2.], [2., 3., 3., 3.]], [[3., 3., 3., 3.], [4., 4., 4., 4.], [4., 4., 4., 4.]]])) NumPy二元函数 函数 说明 + ‐ * / ** 两个数组各元素进行对应运算 np.maximum(x,y) np.fmax() np.minimum(x,y) np.fmin() 元素级的最大值/最小值计算 np.mod(x,y) 元素级的模运算 np.copysign(x,y) 将数组y中各元素值的符号赋值给数组x对应元素 &gt;&lt; &gt;= &lt;= == != 算术比较，产生布尔型数组 12345678910111213141516171819202122232425262728293031323334353637383940414243In [29]: a = np.arange(24).reshape((2,3,4))In [30]: b = np.sqrt(a)In [31]: aOut[31]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])In [32]: bOut[32]: array([[[0. , 1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974, 2.64575131], [2.82842712, 3. , 3.16227766, 3.31662479]], [[3.46410162, 3.60555128, 3.74165739, 3.87298335], [4. , 4.12310563, 4.24264069, 4.35889894], [4.47213595, 4.58257569, 4.69041576, 4.79583152]]])In [33]: np.maximum(a,b)Out[33]: array([[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]], [[12., 13., 14., 15.], [16., 17., 18., 19.], [20., 21., 22., 23.]]])In [34]: a &gt; bOut[34]: array([[[False, False, True, True], [ True, True, True, True], [ True, True, True, True]], [[ True, True, True, True], [ True, True, True, True], [ True, True, True, True]]])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵩天老师Python(9)Python计算生态]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%B5%A9%E5%A4%A9%E8%80%81%E5%B8%88Python(9)Python%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81%2F</url>
    <content type="text"><![CDATA[从数据处理到人工智能数据表示-&gt;数据清洗-&gt;数据统计-&gt;数据可视化-&gt;数据挖掘-&gt;人工智能 数据表示：采用合适方式用程序表达数据 数据清理：数据归一化、数据转换、异常值处理 数据统计：数据的概要理解，数量、分布、中位数等 数据可视化：直观展示数据内涵的方式 数据挖掘：从数据分析获得知识，产生数据外的价值 人工智能：数据/语言/图像/视觉等方面深度分析与决策 Python库之数据分析Numpy: 表达N维数组的最基础库 Python接口使用，C语言实现，计算速度优异 Python数据分析及科学计算的基础库，支撑Pandas等 提供直接的矩阵运算、广播函数、线性代数等功能 Pandas: Python数据分析高层次应用库 提供了简单易用的数据结构和数据分析工具 理解数据类型与索引的关系，操作索引即操作数据 Python最主要的数据分析功能库，基于Numpy开发 Series = 索引 + 一维数据DataFrame = 行列索引 + 二维数据 SciPy: 数学、科学和工程计算功能库 提供了一批数学算法及工程数据运算功能 类似Matlab，可用于如傅里叶变换、信号处理等应用 Python最主要的科学计算功能库，基于Numpy开发 Python库之数据可视化Matplotlib: 高质量的二维数据可视化功能库 提供了超过100种数据可视化展示效果 通过matplotlib.pyplot子库调用各可视化效果 Python最主要的数据可视化功能库，基于Numpy开发 Seaborn: 统计类数据可视化功能库 提供了一批高层次的统计类数据可视化展示效果 主要展示数据间分布、分类和线性关系等内容 基于Matplotlib开发，支持Numpy和Pandas Mayavi：三维科学数据可视化功能库 提供了一批简单易用的3D科学计算数据可视化展示效果 目前版本是Mayavi2，三维可视化最主要的第三方库 支持Numpy、TVTK、Traits、Envisage等第三方库 Python之文本处理PyPDF2：用来处理pdf文件的工具集 提供了一批处理PDF文件的计算功能 支持获取信息、分隔/整合文件、加密解密等 完全Python语言实现，不需要额外依赖，功能稳定 12345678from PyPDF2 import PdfFileReader, PdfFileMergermerger = PdfFileMerger()input1 = open("document1.pdf", "rb")input2 = open("document2.pdf", "rb")merger.append(fileobj = input1, pages = (0,3))merger.merge(position = 2, fileobj = input2, pages = (0,1))output = open("document-output.pdf", "wb")merger.write(output) NLTK：自然语言文本处理第三方库 提供了一批简单易用的自然语言文本处理功能 支持语言文本分类、标记、语法句法、语义分析等 最优秀的Python自然语言处理库 123from nltk.corpus import treebankt = treebank.parsed_sents('wsj_0001.mrg')[0]t.draw() Python-docx：创建或更新Microsoft Word文件的第三方库 提供创建或更新.doc .docx等文件的计算功能 增加并配置段落、图片、表格、文字等，功能全面 123456from docx import Documentdocument = Document()document.add_heading('Document Title', 0)p = document.add_paragraph('A plain paragraph having some ')document.add_page_break()document.save('demo.docx') Python之机器学习Scikit-learn：机器学习方法工具集 提供一批统一化的机器学习方法功能接口 提供聚类、分类、回归、强化学习等计算功能 机器学习最基本且最优秀的Python第三方库 TensorFlow：AlphaGo背后的机器学习计算框架 谷歌公司推动的开源机器学习框架 将数据流图作为基础，图节点代表运算，边代表张量 应用机器学习方法的一种方式，支撑谷歌人工智能应用 123456import tensorflow as tfinit = tf.global_variables_initializer()sess = tf.Session()sess.run(init)res = sess.run(result)print('result:', res) MXNet：基于神经网络的深度学习计算框架 提供可扩展的神经网络及深度学习计算功能 可用于自动驾驶、机器翻译、语音识别等众多领域 Python最重要的深度学习计算框架 实例：霍兰德人格分析雷达图问题分析霍兰德人格分析 霍兰德认为：人格兴趣与职业之间应有一种内在的对应关系 人格分类：研究型、艺术型、社会型、企业型、传统型、现实性 职业：工程师、实验员、艺术家、推销员、记事员、社会工作者 需求 需求：雷达图方式验证霍兰德人格分析 输入：各职业人群结合兴趣的调研数据 输出：雷达图 第三方库的使用 通用雷达图绘制：matplotlib库 专业的多维数据表示：numpy库 输出：雷达图 代码12345678910111213141516171819202122232425262728#HollandRadarDraw.pyimport numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams['font.family']='SimHei'radar_labels = np.array(['研究型(I)','艺术型(A)','社会型(S)',\'企业型(E)','常规型(C)','现实型(R)'])data = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],[0.85, 0.35, 0.30, 0.40, 0.40, 0.30],[0.43, 0.89, 0.30, 0.28, 0.22, 0.30],[0.30, 0.25, 0.48, 0.85, 0.45, 0.40],[0.20, 0.38, 0.87, 0.45, 0.32, 0.28],[0.34, 0.31, 0.38, 0.40, 0.92, 0.28]]) #数据值data_labels = ('艺术家','实验员','工程师','推销员','社会工作者','记事员')angles = np.linspace(0, 2*np.pi, 6, endpoint=False)data = np.concatenate((data, [data[0]]))angles = np.concatenate((angles, [angles[0]]))fig = plt.figure(facecolor="white")plt.subplot(111, polar=True)plt.plot(angles,data,'o-', linewidth=1, alpha=0.2)plt.fill(angles,data, alpha=0.25)plt.thetagrids(angles*180/np.pi, radar_labels,frac = 1.2)plt.figtext(0.52, 0.95, '霍兰德人格分析', ha='center', size=20)legend = plt.legend(data_labels, loc=(0.94, 0.80), labelspacing=0.1)plt.setp(legend.get_texts(), fontsize='large')plt.grid(True)plt.savefig('holland_radar.jpg')plt.show() 从Web解析到网络空间Python库之网络爬虫Requests: 最友好的网络爬虫功能库 提供了简单易用的类HTTP协议网络爬虫功能 支持连接池、SSL、Cookies、HTTP(S)代理等 Python最主要的页面级网络爬虫功能库 Scrapy: 优秀的网络爬虫框架 提供了构建网络爬虫系统的框架功能，功能半成品 支持批量和定时网页爬取、提供数据处理流程等 Python最主要且最专业的网络爬虫框架 pyspider: 强大的Web页面爬取系统 提供了完整的网页爬取系统构建功能 支持数据库后端、消息队列、优先级、分布式架构等 Python重要的网络爬虫类第三方库 Python库之Web信息提取Beautiful Soup: HTML和XML的解析库 提供了解析HTML和XML等Web信息的功能 又名beautifulsoup4或bs4，可以加载多种解析引擎 常与网络爬虫库搭配使用，如Scrapy、requests等 Re: 正则表达式解析和处理功能库 提供了定义和解析正则表达式的一批通用功能 可用于各类场景，包括定点的Web信息提取 Python最主要的标准库之一，无需安装 Python-Goose: 提取文章类型Web页面的功能库 提供了对Web页面中文章信息/视频等元数据的提取功能 针对特定类型Web页面，应用覆盖面较广 Python最主要的Web信息提取库 Python库之Web网站开发Django: 最流行的Web应用框架 提供了构建Web系统的基本应用框架 MTV模式：模型(model)、模板(Template)、视图(Views) Python最重要的Web应用框架，略微复杂的应用框架 Pyramid: 规模适中的Web应用框架 提供了简单方便构建Web系统的应用框架 不大不小，规模适中，适合快速构建并适度扩展类应用 Python产品级Web应用框架，起步简单可扩展性好 Flask: Web应用开发微框架 提供了最简单构建Web系统的应用框架 特点是：简单、规模小、快速 Django &gt; Pyramid &gt; Flask Python库之网络应用开发WeRoBot: 微信公众号开发框架 提供了解析微信服务器消息及反馈消息的功能 建立微信机器人的重要技术手段 aip: 百度AI开放平台接口 提供了访问百度AI服务的Python功能接口 语音、人脸、OCR、NLP、知识图谱、图像搜索等领域 Python百度AI应用的最主要方式 MyQR: 二维码生成第三方库 提供了生成二维码的系列功能 基本二维码、艺术二维码和动态二维码 从人机交互到艺术设计Python库之图形用户界面PyQt5: Qt开发框架的Python接口 提供了创建Qt5程序的Python API接口 Qt是非常成熟的跨平台桌面应用开发系统，完备GUI 推荐的Python GUI开发第三方库 wxPython: 跨平台GUI开发框架 提供了专用于Python的跨平台GUI开发框架 理解数据类型与索引的关系，操作索引即操作数据 Python最主要的数据分析功能库，基于Numpy开发 PyGObject: 使用GTK+开发GUI的功能库 提供了整合GTK+、WebKitGTK+等库的功能 GTK+：跨平台的一种用户图形界面GUI框架 实例：Anaconda采用该库构建GUI Python库之游戏开发PyGame: 简单的游戏开发功能库 提供了基于SDL的简单游戏开发功能及实现引擎 理解游戏对外部输入的响应机制及角色构建和交互机制 Python游戏入门最主要的第三方库 Panda3D: 开源、跨平台的3D渲染和游戏开发库 一个3D游戏引擎，提供Python和C++两种接口 支持很多先进特性：法线贴图、光泽贴图、卡通渲染等 由迪士尼和卡尼基梅隆大学共同开发 cocos2d: 构建2D游戏和图形界面交互式应用的框架 提供了基于OpenGL的游戏开发图形渲染功能 支持GPU加速，采用树形结构分层管理游戏对象类型 适用于2D专业级游戏开发 Python库之虚拟现实VR Zero: 在树莓派上开发VR应用的Python库 提供大量与VR开发相关的功能 针对树莓派的VR开发库，支持设备小型化，配置简单化 非常适合初学者实践VR开发及应用 pyovr: Oculus Rift的Python开发接口 针对Oculus VR设备的Python开发库 基于成熟的VR设备，提供全套文档，工业级应用设备 Python+虚拟现实领域探索的一种思路 Vizard: 基于Python的通用VR开发引擎 专业的企业级虚拟现实开发引擎 提供详细的官方文档 支持多种主流的VR硬件设备，具有一定通用性 Python库之图形艺术Quads: 迭代的艺术 对图片进行四分迭代，形成像素风 可以生成动图或静图图像 简单易用，具有很高展示度 ascii_art: ASCII艺术库 将普通图片转为ASCII艺术风格 输出可以是纯文本或彩色文本 可采用图片格式输出 实例: 玫瑰花绘制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# RoseDraw.pyimport turtle as t# 定义一个曲线绘制函数def DegreeCurve(n, r, d=1): for i in range(n): t.left(d) t.circle(r, abs(d))# 初始位置设定s = 0.2 # sizet.setup(450*5*s, 750*5*s)t.pencolor("black")t.fillcolor("red")t.speed(100)t.penup()t.goto(0, 900*s)t.pendown()# 绘制花朵形状t.begin_fill()t.circle(200*s,30)DegreeCurve(60, 50*s)t.circle(200*s,30)DegreeCurve(4, 100*s)t.circle(200*s,50)DegreeCurve(50, 50*s)t.circle(350*s,65)DegreeCurve(40, 70*s)t.circle(150*s,50)DegreeCurve(20, 50*s, -1)t.circle(400*s,60)DegreeCurve(18, 50*s)t.fd(250*s)t.right(150)t.circle(-500*s,12)t.left(140)t.circle(550*s,110)t.left(27)t.circle(650*s,100)t.left(130)t.circle(-300*s,20)t.right(123)t.circle(220*s,57)t.end_fill()# 绘制花枝形状t.left(120)t.fd(280*s)t.left(115)t.circle(300*s,33)t.left(180)t.circle(-300*s,33)DegreeCurve(70, 225*s, -1)t.circle(350*s,104)t.left(90)t.circle(200*s,105)t.circle(-500*s,63)t.penup()t.goto(170*s,-30*s)t.pendown()t.left(160)DegreeCurve(20, 2500*s)DegreeCurve(220, 250*s, -1)# 绘制一个绿色叶子t.fillcolor('green')t.penup()t.goto(670*s,-180*s)t.pendown()t.right(140)t.begin_fill()t.circle(300*s,120)t.left(60)t.circle(300*s,120)t.end_fill()t.penup()t.goto(180*s,-550*s)t.pendown()t.right(85)t.circle(600*s,40)# 绘制另一个绿色叶子t.penup()t.goto(-150*s,-1000*s)t.pendown()t.begin_fill()t.rt(120)t.circle(300*s,115)t.left(75)t.circle(300*s,100)t.end_fill()t.penup()t.goto(430*s,-1070*s)t.pendown()t.right(30)t.circle(-600*s,35)t.done()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵩天老师Python(8)程序设计方法学]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%B5%A9%E5%A4%A9%E8%80%81%E5%B8%88Python(8)%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[实例：体育竞技分析 高手过招，胜负只在毫厘之间 “体育竞技分析”问题分析体育竞技分析 需求：毫厘是多少？如何科学分析体育竞技比赛？ 输入：球员的水平 输出：可预测的比赛成绩 体育竞技分析：模拟N场比赛 计算思维：抽象 + 自动化 模拟：抽象比赛过程 + 自动化执行N场比赛 当N越大时，比赛结果分析会越科学 比赛规则 双人击球比赛：A &amp; B，回合制，5局3胜 开始时一方先发球，直至判分，接下来胜者发球 球员只能在发球局得分，15分胜一局 自顶向下和自底向上自顶向下（设计）——解决复杂问题的有效方法 将一个总问题表达为若干个小问题组成的形式 使用同样方法进一步分解小问题 直至，小问题可以用计算机简单明了的解决 自底向上（执行）——逐步组建复杂系统的有效测试方法代码实现程序总体框架及步骤 步骤1：打印程序的介绍性信息 - printInfo() 步骤2：获得程序运行参数：proA, proB, n - getInputs() 步骤3：利用球员A和B的能力值，模拟n局比赛 - simNGames() 步骤4：输出球员A和B获胜比赛的场次及概率 - printSummary() 全代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from random import randomdef printIntro(): print("这个程序模拟两个选手A和B的某种竞技比赛") print("程序运行需要A和B的能力值（以0到1之间的小数表示）")def getInputs(): a = eval(input("请输入选手A的能力值（0-1）：")) b = eval(input("请输入选手B的能力值（0-1）：")) n = eval(input("模拟比赛的场次：")) return a, b, ndef printSummary(winsA, winsB): n = winsA + winsB print("竞技分析开始，共模拟&#123;&#125;场比赛".format(n)) print("选手A获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;".format(winsA, winsA/n)) print("选手B获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;".format(winsB, winsB/n))def gameOver(a, b): return a==15 or b==15def simOneGame(probA, probB): scoreA, scoreB = 0, 0 serving ="A" while not gameOver(scoreA,scoreB): if serving == "A": if random() &lt; probA: scoreA += 1 else: serving = "B" else: if random() &lt; probB: scoreB += 1 else: serving = "A" return scoreA, scoreBdef simNGames(n, probA, probB): winsA, winsB = 0, 0 for i in range(n): scoreA, scoreB = simOneGame(probA, probB) if scoreA &gt; scoreB: winsA += 1 else: winsB += 1 return winsA, winsBdef main(): printIntro() probA, probB, n = getInputs() winsA, winsB = simNGames(n, probA, probB) printSummary(winsA, winsB)main() 结果展示 举一反三 理解自顶向下和自底向上 理解自顶向下的设计思维：分而治之 理解自底向上的执行思维：模块化集成 自顶向下是“系统”思维的简化 应用问题的扩展 扩展比赛参数，增加对更多能力对比情况的判断 扩展比赛设计，增加对真实比赛结果的预测 扩展分析逻辑，反向推理，用胜率推算能力？ Python程序设计思维计算思维第3种人类思维特征 逻辑思维：推理和演绎，数学为代表，A-&gt;B B-&gt;C A-&gt;C 实证思维：实验和验证，物理为代表，引力波&lt;-实验 计算思维：设计和构造，计算机为代表，汉诺塔递归 计算思维（Computational Thinking）：抽象问题的计算过程，利用计算机自动化求解，是基于计算机的思维方式。计算思维基于计算机强大的算力及海量数据，抽象计算过程，关注设计和构造，而非因果。 计算生态与Python语言 以开源项目为代表的大量第三方库 库的建设经过野蛮生长和自然选择 库之间相互关联使用，依存发展 社区庞大，新技术更迭迅速 计算生态的价值 加速科技类应用创新的重要支撑 发展科技产品商业价值的重要模式 国家科技体系安全和稳固的基础 基本的程序设计模式IPO模块化设计配置化设计 Python第三方库安装Python社区：https://pypi.org 安装第三方库： 主要方法：使用pip命令 集成安装方法 文件安装方法 Anaconda： https://www.continuum.io 支持近800个第三方库 包含多个主流工具 适合数据计算领域开发 UCI页面： http://www.lfd.uci.edu/~gohlke/pythonlibs/ 在UCI页面上搜索&lt;库名称&gt; 下载对应版本的文件 使用pip install &lt;文件名&gt;安装 os库的使用os库基本介绍os库提供通用的、基本的操作系统交互功能 os库是Python标准库，包含几百个函数 常用路径操作、进程管理、环境参数等几类 路径操作：os.path子库，处理文件路径及信息 进程管理：启动系统中其他程序 环境参数：获得系统软硬件信息等环境参数 os库的路径操作os.path子库以path为入口，用于操作和处理文件路径| 函数 | 描述 || ————————— | ——————————— || os.path.abspath(path) | 返回path在当前系统中的绝对路径 || os.path.normpath(path) | 归一化path的表示形式，统一用\\分隔路径 || os.path.relpath(path) | 返回当前程序与文件之间的相对路径（relative path）|| os.path.dirname(path) | 返回path中的目录名称 || os.path.basename(path) | 返回path中最后的文件名称 || os.path.join(path,*paths) | 组合path与paths，返回一个路径字符串 || os.path.exists(path) | 判断path对应文件或目录是否存在，返回True或False || os.path.isfile(path) | 判断path所对应是否为已存在的文件，返回True或False|| os.path.isdir(path) | 判断path所对应是否为已存在的目录，返回True或False || os.path.getatime(path) | 返回path对应文件或目录上一次的访问时间 || os.path.getmtime(path) | 返回path对应文件或目录最近一次的修改时间 || os.path.getctime(path) | 返回path对应文件或目录创建时间 || os.path.getsize(path) | 返回path对应文件的大小，以字节为单位 | os库的进程管理1os.system(command) 执行程序或命令command 在Windows操作系统中，返回值为cmd调用的返回信息 os库的环境参数获取或改变系统环境信息| 函数 | 描述 || —————- | ———————————————– || os.chdir(path) | 修改当前程序的操作路径 || os.getcwd() | 返回程序的当前路径 || os.getlogin() | 获得当前系统登录用户名称 || os.cpu_count() | 获得当前系统CPU数量 || os.urandom(n) | 获得n个字节长度的随机字符串，通常用于加解密运算 | 实例：第三方库安装脚本问题分析 需求：批量安装第三方库需要人工干预，能否自动安装？ 自动执行pip逐一根据需求安装 库名 用途 pip安装指令 NumPy N维数据表示和运算 pip install numpy Matplotlib 二维数据可视化 pip install matplotlib PIL 图像处理 pip install pillow Scikit-Learn 机器学习和数据挖掘 pip install sklearn Requests HTTP协议访问及网络爬虫 pip install requests Jieba 中文分词 pip install jieba Beautiful Soup HTML和XML解析器 pip install beautifulsoup4 Wheel Python 第三方库文件打包工具 pip install wheel PyInstaller 打包Python源文件为可执行文件 pip install pyinstall Flask 轻量级Web开发框架 pip install flask WeRoBot 微信机器人开发框架 pip install werobot SymPy 数学符号计算工具 pip install sympy Pandas 高效数据分析和计算 pip install pandas Networkx 复杂网络和图结构的建模和分析 pip install networkx PyQt5 基于Qt的专业级GUI开发框架 pip install pyqt5 PyOpenGL 多平台OpenGL开发接口 pip install pyopengl PyPDF2 PDF文件内容提取及处理 pip install pypdf2 docopt Python命令行解析 pip install docopt PyGame 简单小游戏开发框架 pip install pygame 实例解析123456789101112#BatchInstall.pyimport oslibs = &#123;"numpy","matplotlib","pillow","sklearn","requests",\ "jieba","beautifulsoup4","wheel","networkx","sympy",\ "pyinstaller","django","flask","werobot","pyqt5",\ "pandas","pyopengl","pypdf2","docopt","pygame"&#125;try: for lib in libs: os.system("pip install" + lib) print("Successful")except: print("Failed Somehow") 举一反三自动化脚本+ 编写各类自动化运行程序的脚本，调用已有程序 扩展应用：安装更多第三方库，增加配置文件 扩展异常检测：捕获更多异常类型，程序更稳定友好]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵩天老师Python(7)文件和数据格式化]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%B5%A9%E5%A4%A9%E8%80%81%E5%B8%88Python(7)%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[文件的使用文件的类型文件的理解文件是数据的抽象和集合 文件是存储在辅助存储器上的数据序列 文件是数据存储的一种形式 文件展现形态：文本文件和二进制文件 文本文件 vs 二进制文件 文本文件和二进制文件只是文件的展示方式 本质上，所有文件都是二进制形式存储 形式上，所有文件采用两种方式展示 文本文件 由单一特定编码组成的文件，如UTF-8编码 由于存在编码，也被看成是存储着的长字符串 适用于例如：.txt文件、.py文件 二进制文件 直接由比特0和1组成，没有统一字符编码 一般存在二进制0和1的组织结构，即文件格式 适用于例如：.png文件、.avi文件等 文件的打开和关闭文件处理的步骤：打开-操作-关闭 123sequenceDiagram文件的存储状态-&gt;&gt;文件的占用状态: a = open( , )文件的占用状态-&gt;&gt;文件的存储状态: a.close() 文件打开以后就可以对文件进行读写 123456789//读文件函数a.read(size)a.readline(size)a.readlines(hint)//写文件函数a.write(s)a.writelines(lines)a.seek(offset) 文件路径1&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;) 打开模式 文件的打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 ‘+’ 与r/w/x/a一同使用，在原功能基础上增加同时读写功能 文件的关闭1&lt;文件名&gt;.close() 文件内容的读取 操作方法 描述 .read(size=-1) 读入全部内容，如果给出参数，读入前size长度 .readline(size=-1) 读入全部内容，如果给出参数，读入该行前size长度 .readlines(hint=-1) 读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行 文件的全文本操作 遍历全文本：方法一 12345fname = input("请输入要打开的文件名称：")fo = open(fname,"r")txt = fo.read()#对全文txt进行处理fo.close() 遍历全文本：方法二 1234567fname = input("请输入要打开的文件名称：")fo = open(fname,"r")txt = fo.read(2)while txt != "": #对txt进行处理 txt = fo.read(2)fo.close() 文件的逐行操作 逐行遍历文件：方法一 12345fname = input("请输入要打开的文件名称：")fo = open(fname,"r")for line in fo.readlines(): print(line)fo.close() 逐行遍历文件：方法二 12345fname = input("请输入要打开的文件名称：")fo = open(fname,"r")for line in fo: print(line)fo.close() 数据的文件写入 操作方法 描述 .write(s) 向文件写入一个字符串或字节流 .writelines(lines) 将一个元素全为字符串的列表写入文件 .seek(offset) 改变当前文件操作指针的位置，offset含义如下：0-文件开头，1-当前位置，2-文件结尾 123456fo = open("output.txt","w+")ls = ["中国","法国","美国"]fo.writelines(ls)for line in fo: print(line)fo.close() 此时控制台没有任何输出 1234567fo = open("output.txt","w+")ls = ["中国","法国","美国"]fo.writelines(ls)fo.seek(0)for line in fo: print(line)fo.close() 此时输出“中国法国美国” 实例：自动轨迹绘制问题分析 需求：根据脚本来绘制图形 不是写代码而是数据绘制图形 数据脚本是自动化最重要的第一步 基本思路 步骤1：定义数据文件格式（接口） 步骤2：编写程序，根据文件接口解析参数绘制图形 步骤3：编制数据文件 编写程序12345678910111213141516171819202122#AutoTraceDraw.pyimport turtle as tt.title('自动轨迹绘制')t.setup(800,600,0,0)t.pencolor("red")t.pensize(5)#数据读取datals = []f = open("data.txt")for line in f: line = line.replace("\n","") datals.append(list(map(eval, line.split(","))))#自动绘制for i in range(len(datals)): t.pencolor(datals[i][3],datals[i][4],datals[i][5]) t.fd(datals[i][0]) if datals[i][1]: t.right(datals[i][2]) else: t.left(datals[i][2]) 数据文件data.txt 123456789101112131415300,0,144,1,0,0300,0,144,0,1,0300,0,144,0,0,1300,0,144,1,1,0300,0,108,0,1,1184,0,72,1,0,1184,0,72,0,0,0184,0,72,0,0,0184,0,72,0,0,0184,1,72,1,0,1184,1,72,0,0,0184,1,72,0,0,0184,1,72,0,0,0184,1,72,0,0,0184,1,720,0,0,0 运行结果 一维数据的格式化和处理数据组织的维度从一个数据到一组数据：一个数据表达一个含义，一组数据表达一个或多个含义 一维数据：由对等关系的有序或无序数据构成，采用线性方式组织，对应列表、数组、集合等概念。 二维数据：由多个一维数据构成，是一维数据的组合形式。表格是典型的二维数据。 多维数据：由一维或二维数据在新的维度上扩展形成 高维数据：键值对 数据的操作周期：存储&lt;->表示&lt;->操作 一维数据的表示如果数据间有序：使用列表类型 列表类型可以表达一维有序数据 for循环可以遍历数据，进而对每个数据进行处理 如果数据间无序：使用集合类型 集合类型可以表达一维无需数据 for循环可以遍历数据，进而对每个数据进行处理 一维数据的存储 存储方式一：空格分隔 使用一个或多个空格分隔进行存储，不换行 缺点：数据中不能存在空格 存储方式二：逗号分隔 使用英文半角逗号分隔数据进行存储，不换行 缺点：数据中不能有英文逗号 存储方式三：其他方式 使用其他符号或符号组合分隔，建议采用特殊符号 缺点：需要根据数据特点定义，通用性较差 一维数据的处理从空格分割的文件中读入数据123txt = open(fname).read()ls = txt.split()f.close() 从特殊符号分割的文件中读入数据123txt = open(fname).read()ls = txt.split("$")f.close() 采用空格分隔方式将数据写入文件1234ls = ["中国","美国","日本"]f = open(fname,'w')f.write(' '.join(ls))f.close() 二维数据的格式化和处理二维数据的表示使用列表类型（二维列表） 使用两层for循环遍历每个元素 外层列表中每个元素可以对应一行，也可以对应一列 CSV格式与二维数据的存储CSV：Comma-Separated Values 国际通用的一二维数据存储格式，一般.csv扩展名 每行一个一维数据，采用逗号分隔，无空行 Excel可读入输出，一般编辑软件都可以产生 如果某个元素确缺失，逗号仍要保留 二维数据的表头可以作为数据存储，也可以另行存储 二维数据的存储 按行存或按列存都可以，具体由程序决定 一般索引习惯：ls[row][column]，先行后列 根据一般习惯，外层列表每个元素是一行，按行存 二维数据的处理从CSV文件中读入数据 123456fo = open(fname)ls =[]for line in fo: line = line.replace("\n","") ls.append(line.split(","))fo.close() 将数据写入CSV文件 12345ls = [[],[],[]] #二维列表f.open(fname,'w')for item in ls: f.write(','.join(item) + '\n')f.close() 二维数据的逐一处理 1234ls = [[],[],[]] #二维列表for row in ls: for column in row: print(ls[row][column]) wordcloud库的使用基本介绍wordcloud是优秀的词云展示的第三方库，词云以词语为基本单位，更加直观和艺术的展示文本。 安装命令1pip install wordcloud 使用说明wordcloud库把词云当作一个WordCloud对象 wordcloud.WordCloud()代表一个文本对应的词云 可以根据文本中词语出现的频率等参数绘制词云 词云的形状、尺寸和颜色都可以设定 wordcloud库常规方法1w = wordcloud.WordCloud() 以WordCloud对象为基础 配置参数、加载文本、输出文件 方法 描述 w.generate(txt) 向WordCloud对象w中加载文本txt，w.generate(&quot;python and wordcloud&quot;) w.to_file(filename) 将词云输出成图像文件，.png或.jpg格式，w.to_file(&quot;outfile.png&quot;) 步骤1：配置对象参数 步骤2：加载词云文本 步骤3：输出词云文件 1234import wordcloudc = wordcloud.WordCloud()c.generate("wordcloud by python")c.to_file("pywordcloud.png") 从文本到图片，wordcloud做了哪些事情呢？ 分隔：以空格分隔单词 统计：单词出现次数并过滤 字体：根据统计配置字号 布局：颜色环境尺寸 wordcloud配置对象参数1w = wordcloud.WordCloud(&lt;参数&gt;) 参数 描述 width 指定词云对象生成图片的宽度，默认400像素 height 指定词云对象生成图片的高度，默认200像素 min_font_size 指定词云中字体的最小字号，默认4号 max_font_size 指定词云中字体的最大字号，根据高度自动调节 font_step 指定词云中字体字号的不进间隔，默认为1 font_path 指定字体文件的路径，默认None max_words 指定词云显示的最大单词数量，默认为200 stop_words 指定词云的排除词列表，即不显示的单词列表 mask 指定词云形状，默认为长方形，需要引用imread()函数 background_color 指定词云图片的背景颜色，默认为黑色 1234#指定词云形状，默认为长方形，需要引用imread()函数from scipy.misc import imread mk = imread("pic.png")w = wordcloud.WordCloud(mask = mk) 两个小demo123456import wordcloudtxt = "life is short, you need python"w = wordcloud.WordCloud( \ background_color = "white")w.generate(txt)w.to_file("d:/pywordcloud.png") 12345678910import jiebaimport wordcloudtxt = "程序设计语言是计算机能够理解和\识别用户操作意图的一种交互体系,它按照\特定规则组织计算机指令,使计算机能够自\动进行各种运算处理。"w = wordcloud.WordCloud( width = 1000, \ font_path = "msyh.ttc", height = 700)w.generate(" ".join(jieba.lcut(txt)))w.to_file("d:/zhongwenciyun.jpg") 实例：政府工作报告词云问题分析直观理解政策文件 需求：对于政府工作报告等政策文件，如何直观理解？ 体会直观的价值：生成词云 &amp; 优化词云 12graph LR政府工作报告等文件 --&gt; 有效展示的词云 基本思路和代码实现 步骤1：读取文件，分词整理 步骤2：设置并输出词云 步骤3：观察结果，优化迭代 12345678910111213#GovRpWordCloudv1.pyimport jiebaimport wordcloudf = open("关于实施乡村振兴战略的意见.txt","r",encoding="utf-8")#f = open("新时代中国特色社会主义.txt","r",encoding="utf-8")t = f.read()f.close()ls = jieba.lcut(t)txt = " ".join(ls)#w = wordcloud.WordCloud(max_words = 15,font_path = "msyh.ttc",width = 1000,height = 700,background_color = "white")w = wordcloud.WordCloud(font_path = "msyh.ttc",width = 1000,height = 700,background_color = "white")w.generate(txt)w.to_file("GovRpWordCloudv1.png") 运行程序后，两个报告的词云如下： 增加参数max_words=15，结果如下： 增加形状mask = mask，词云图更加漂亮：123456789101112131415#GovRpWordCloudv1.pyimport jiebaimport wordcloudfrom scipy.misc import imreadmask = imread("chinamap.jpg")#mask = imread("fivestars.png")f = open("关于实施乡村振兴战略的意见.txt","r",encoding="utf-8")#f = open("新时代中国特色社会主义.txt","r",encoding="utf-8")t = f.read()f.close()ls = jieba.lcut(t)txt = " ".join(ls)w = wordcloud.WordCloud(mask = mask,font_path = "msyh.ttc",width = 1000,height = 700,background_color = "white")w.generate(txt)w.to_file("GovRpWordCloudv1.png") 结果展示： 扩展能力 了解wordcloud更多参数，扩展词云能力 特色词云：设计一款属于自己的特色词云风格 更多文件：用更多文件练习词云生成 练习素材下载：新时代中国特色社会主义.txt/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89.txt)关于实施乡村振兴战略的意见.txt/%E5%85%B3%E4%BA%8E%E5%AE%9E%E6%96%BD%E4%B9%A1%E6%9D%91%E6%8C%AF%E5%85%B4%E6%88%98%E7%95%A5%E7%9A%84%E6%84%8F%E8%A7%81.txt)chinamap.jpg/chinamap.jpg)fivestars.png/fivestars.png)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵩天老师Python(6)组合数据类型]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%B5%A9%E5%A4%A9%E8%80%81%E5%B8%88Python(6)%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[集合类型及操作集合类型的定义集合类型的定义：集合是多个元素的无序组合 集合类型与数学中的集合概念一致 集合元素之间无序，每个元素唯一，不存在相同元素 集合元素不可更改，不能是可变数据类型 集合用大括号{}表示，元素间用逗号分隔 建立集合类型用{}或set() 建立空集合类型，必须使用set() 12345678&gt;&gt;&gt; A = &#123;"python",123,("python",123)&#125; #使用&#123;&#125;建立集合&#123;'python', ('python', 123), 123&#125;&gt;&gt;&gt; B = set("pypy123") #使用set()建立集合&#123;'2', '3', 'p', 'y', '1'&#125;&gt;&gt;&gt; C = &#123;"python",123,"python",123&#125;&#123;'python', 123&#125; 重点 集合用大括号{}表示，元素间用逗号分隔 集合元素之间无序 集合中每个元素唯一，不存在相同元素 集合操作符集合间操作：并差交补 操作符及应用 描述 `S T` 返回一个新集合，包括在集合S和T中的所有元素 S-T 返回一个新集合，包括在集合S但不在T中的元素 S&amp;T 返回一个新集合，包括同时在集合S和T中的元素 S^T 返回一个新集合，包括集合S和T中的非相同元素 S&lt;=T或S&lt;T 返回True/False,判断S和T的子集关系 S&gt;=T或S&gt;T 返回True/False,判断S和T的包含关系 4个增强操作符 操作符及应用 描述 `S =T` 更新集合S，包括在集合S和T中的所有元素 S-=T 更新集合S，包括在集合S但不在T中的元素 S&amp;=T 更新集合S，包括同时在集合S和T中的元素 S^=T 更新集合S，包括集合S和T中的非相同元素 123456789101112&gt;&gt;&gt; A = &#123;"p","y",123&#125;&gt;&gt;&gt; B = set("pypy123")&gt;&gt;&gt; A - B&#123;123&#125;&gt;&gt;&gt; B - A&#123;'2', '3', '1'&#125;&gt;&gt;&gt; A &amp; B&#123;'y', 'p'&#125;&gt;&gt;&gt; A | B&#123;'2', '3', 'p', 'y', 123, '1'&#125;&gt;&gt;&gt; A ^ B&#123;'2', '3', 123, '1'&#125; 集合处理方法 操作函数或方法 描述 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x，如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回集合S的一个副本 len(S) 返回集合S的元素个数 x in S 判断S中元素x，x在集合S中，返回True，否则返回False x not in S 判断S中元素x，x不在集合S中，返回False，否则返回True set(x) 将其他类型变量x转换为集合类型 12345&gt;&gt;&gt; A = &#123;"p","y",123&#125;&gt;&gt;&gt; for item in A: print(item,end="")y123p 123456789&gt;&gt;&gt; try: while True: print(A.pop(), end="") except: passy123p&gt;&gt;&gt; Aset() 集合类型应用场景包含关系比较 1234&gt;&gt;&gt; "p" in &#123;"p","y",123&#125;True&gt;&gt;&gt; &#123;"p","y"&#125; &gt;= &#123;"p","y",123&#125;False 数据去重：集合类型所有元素无重复 1234567&gt;&gt;&gt; ls = ["p","p","y","y",123]&gt;&gt;&gt; s = set(ls)&gt;&gt;&gt; s&#123;'y', 123, 'p'&#125;&gt;&gt;&gt; lt = list(s)&gt;&gt;&gt; lt['y', 123, 'p'] 序列类型及操作序列类型定义：序列是具有先后关系的一组元素 序列是一维元素的向量，元素类型可以不同 类似数学元素序列 元素间由序号引导，通过下标访问序列的特定元素 序列是一个基类类型： graph LR 序列类型-->字符串类型 序列类型-->元组类型 序列类型-->列表类型 序列类型通用操作符 操作符及应用 描述 x in s 如果x是序列s的元素，则返回True，否则返回False x not in s 如果x是序列s的元素，则返回False，否则返回True s + t 连接两个序列s和t s*n 或 n*s 将序列s复制n次 s[i] 索引，返回s中第i个元素，i是序列的序号 s[i:j]或s[i:j:k] 切片，返回序列s中第i到j以k为步长的元素子序列 12345678#::-1可以取反&gt;&gt;&gt; ls = ["python",123,".io"]&gt;&gt;&gt; ls[::-1]['.io', 123, 'python']&gt;&gt;&gt; s = "python123.io"&gt;&gt;&gt; s[::-1]'oi.321nohtyp' 序列类型通用函数和方法5个函数和方法 函数和方法 描述 len(s) 返回序列s的长度 min(s) 返回序列s中的最小元素，s中的元素需要可比较 max(s) 返回序列s中的最大元素，s中的元素需要可比较 s.index(x)或s.index(x,i,j) 返回序列s从i开始到j位置中第一次出现元素x的位置 s.count(x) 返回序列s中出现x的总次数 123456&gt;&gt;&gt; ls = ["python",123,".io"]&gt;&gt;&gt; len(ls)3&gt;&gt;&gt; s = "python123.io"&gt;&gt;&gt; max(s)'y' 元组类型及操作元组类型的定义元组是序列类型的一种扩展 元组是一种序列类型，一旦创建就不能被修改 使用小括号()或tuple()创建，元素间用逗号,分隔 可以使用或不使用小括号 1234567&gt;&gt;&gt; creature = "cat","dog","tiger","human"&gt;&gt;&gt; creature('cat', 'dog', 'tiger', 'human')&gt;&gt;&gt; color = (0x001100,"blue",creature)&gt;&gt;&gt; color(4352, 'blue', ('cat', 'dog', 'tiger', 'human')) 元组类型操作 元组继承序列类型的全部通用操作 因为元组创建后不能修改，所以没有特殊操作 1234567&gt;&gt;&gt; creature = "cat","dog","tiger","human"&gt;&gt;&gt; creature[::-1]('human', 'tiger', 'dog', 'cat')&gt;&gt;&gt; color = (0x001100,"blue",creature)&gt;&gt;&gt; color[-1][2]'tiger' 列表类型及操作列表类型定义列表是序列类型的一种扩展，十分常用 列表是一种序列类型，创建后可以随意被修改 使用方括号[]或list()创建，元素间用逗号,分隔 可以使用或不使用方括号 12345678&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; ls['cat', 'dog', 'tiger', 1024]&gt;&gt;&gt; lt = ls&gt;&gt;&gt; lt['cat', 'dog', 'tiger', 1024]#赋值并没有创建新列表，而相当于重新命名（类似指针） 列表类型操作函数和方法 函数和方法 描述 ls[i] = x 替换列表ls第i元素为x ls[i:j:k] = lt 用列表lt替换ls切片后所对应元素子列表 del ls[i] 删除列表ls第i元素 del ls[i:j:k] 删除列表ls中第i到第j以k为步长的元素 ls += lt 更新列表ls，将lt列表的元素增加到ls中 ls *= n 更新列表ls，其元素重复n次 123456789&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; ls[1:2] = [1,2,3,4]&gt;&gt;&gt; ls['cat', 1, 2, 3, 4, 'tiger', 1024]&gt;&gt;&gt; del ls[::3]&gt;&gt;&gt; ls[1, 2, 4, 'tiger']&gt;&gt;&gt; ls*2[1, 2, 4, 'tiger', 1, 2, 4, 'tiger'] 函数或方法 描述 ls.append(x) 在列表ls最后增加一个元素x ls.clear() 删除列表ls中的所有元素 ls.copy() 生成一个新列表，赋值ls中所有元素 ls.insert(i,x) 在列表ls的第i位置增加元素x ls.pop(i) 将列表ls中第i位置元素取出并删除该元素 ls.remove(x) 将列表ls中出现的第一个元素x删除 ls.reverse() 将列表ls中的元素反转 12345678910&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; ls.append(1234)&gt;&gt;&gt; ls['cat', 'dog', 'tiger', 1024, 1234]&gt;&gt;&gt; ls.insert(3,"human")&gt;&gt;&gt; ls['cat', 'dog', 'tiger', 'human', 1024, 1234]&gt;&gt;&gt; ls.reverse()&gt;&gt;&gt; ls[1234, 1024, 'human', 'tiger', 'dog', 'cat'] 序列类型应用场景 元组用于元素不改变的应用场景，更多应用于固定搭配场景 列表更加灵活，它是最常用的序列类型 最主要作用：表示一组有序数据，进而操作它们 元素遍历12345for item in ls : &lt;语句块&gt; for item in tp : &lt;语句块&gt; 数据保护如果不希望数据被程序所改变，转换成元组类型1234&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; lt = tuple(ls)&gt;&gt;&gt; lt('cat', 'dog', 'tiger', 1024) 实例：基本统计值计算实例：基本统计值计算12345678910111213141516171819202122232425262728293031323334353637#CalStatisticsV1.py#获取用户不定长度的输入def getNum(): nums = [] iNumStr = input("请输入数字（回车退出）：") while iNumStr != "": nums.append(eval(iNumStr)) iNumStr = input("请输入数字（回车退出）：") return nums#计算平均值def mean(numbers): s = 0.0 for num in numbers: s = s + num return s / len(numbers)#计算方差def dev(numbers, mean): sdev = 0.0 for num in numbers: sdev = sdev + (num - mean)**2 return pow(sdev / (len(numbers)-1), 0.5)#计算中位数def median(numbers): sorted(numbers) size = len(numbers) if size % 2 == 0: med = (numbers[size//2-1] + numbers[size//2])/2 else: med = numbers[size//2] return medn = getNum()m = mean(n)print("平均值:&#123;&#125;,方差:&#123;:.2&#125;,中位数:&#123;&#125;.".format(m, dev(n,m), median(n))) 字典类型及操作字典类型定义理解“映射”：映射是一种键（索引）和值（数据）的对应字典类型是“映射”的体现 键值对：键是数据索引的扩展 字典是键值对的集合，键值对之间无序 采用大括号{}和dict()创建，键值对用冒号:表示 12345&gt;&gt;&gt; d = &#123;"中国":"北京","美国":"华盛顿","法国":"巴黎"&#125;&gt;&gt;&gt; d&#123;'中国': '北京', '美国': '华盛顿', '法国': '巴黎'&#125;&gt;&gt;&gt; d["中国"]'北京' 字典类型操作函数及方法 函数或方法 描述 del d[k] 删除字典d中键k对应的数据值 k in d 判断键k是否在字典d中，如果在则返回True，否则False d.keys() 返回字典d所有的键信息 d.values() 返回字典d所有的值信息 d.items() 返回字典d所有的键值对信息 123456789&gt;&gt;&gt; d = &#123;"中国":"北京","美国":"华盛顿","法国":"巴黎"&#125;&gt;&gt;&gt; "中国" in dTrue&gt;&gt;&gt; d.keys()dict_keys(['中国', '美国', '法国'])&gt;&gt;&gt; d.values()dict_values(['北京', '华盛顿', '巴黎'])&gt;&gt;&gt; d.items()dict_items([('中国', '北京'), ('美国', '华盛顿'), ('法国', '巴黎')]) 函数或方法 描述 d.get(k, ) 键k存在，则返回相应值，不在则返回值 d.pop(k, ) 键k存在，则取出相应值，不在则返回值 d.popitem() 随机从字典d中取出一个键值对，以元组形式返回 d.clear() 删除所有键值对 len(d) 返回字典d中元素的个数 123456&gt;&gt;&gt; d.get("中国","伊斯兰堡")'北京'&gt;&gt;&gt; d.get("巴基斯坦","伊斯兰堡")'伊斯兰堡'&gt;&gt;&gt; d.popitem()('法国', '巴黎') 字典类型应用场景映射的表达 映射无处不在，键值对无处不在 例如：统计数据出现的次数，数据是键，次数是值 最主要作用：表达键值对数据，进而操作它们 元素遍历12for k in d: &lt;语句块&gt; jieba库的使用jieba库的基本介绍概述：jieba是优秀的中文分词第三方库 中文文本需要通过分词获得单个的词语 jieba是优秀的中文分词第三方库，需要额外安装 jieba库提供三种分词模式，最简单只需掌握一个函数 jieba库的安装1pip install jieba jieba分词的原理jieba分词依靠中文词库 利用一个中文词库，确定汉字之间的关联概率 汉字之间概率大的组成词组，形成分词结果 除了分词，用户还可以添加自定义的词组 jieba分词的三种模式精确模式、全模式、搜索引擎模式 精确模式：把文本精确地切分开，不存在冗余单词 全模式：把文本中所有可能的词语都扫描出来，有冗余 搜索引擎模式：在精确模式基础上，对长词再次切分 jieba库常用函数 函数 描述 jiaba.lcut(s) 精确模式，返回一个列表类型的分词结果 jieba.lcut(s, cut_all=True) 全模式，返回一个列表类型的分词结果，存在冗余 jieba.lcut_for_search(s) 搜索引擎模式，返回一个列表类型的分词结果，存在冗余 jieba.add_word(w) 向分词词典增加新词w 123456789101112&gt;&gt;&gt; import jieba&gt;&gt;&gt; jieba.lcut("中国是一个伟大的国家")Building prefix dict from the default dictionary ...Dumping model to file cache C:\Users\dreamorz\AppData\Local\Temp\jieba.cacheLoading model cost 1.020 seconds.Prefix dict has been built succesfully.['中国', '是', '一个', '伟大', '的', '国家']&gt;&gt;&gt; jieba.lcut("中国是一个伟大的国家",cut_all=True)['中国', '国是', '一个', '伟大', '的', '国家']&gt;&gt;&gt; jieba.lcut_for_search("中华人民共和国是伟大的")['中华', '华人', '人民', '共和', '共和国', '中华人民共和国', '是', '伟大', '的']&gt;&gt;&gt; jieba.add_word("蟒蛇语言") jieba分词要点1jieba.lcut(s) 实例：文本词频统计（英文&amp;中文）Hamlet词频统计123456789101112131415161718#CalHamletV1.pydef getText(): txt = open("E:/python/hamlet.txt","r").read() txt = txt.lower() for ch in '!"#$%&amp;()*+,-./;:&lt;=&gt;?@[\\]^_&#123;|&#125;~': txt = txt.replace(ch, " ") return txthamletTxt = getText()words = hamletTxt.split()counts = &#123;&#125;for word in words: counts[word] = counts.get(word,0) + 1items = list(counts.items())items.sort(key=lambda x:x[1],reverse=True)for i in range(10): word, count = items[i] print("&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;".format(word, count)) 《三国演义》人物出场统计123456789101112131415161718192021222324252627#CalThreeKingdomsV1.pyimport jiebatxt = open("threekingdoms.txt","r",encoding="utf-8").read()excludes = &#123;"将军","却说","二人","不可","荆州","不能","如此","商议","如何","今日","不敢","魏兵","陛下","一人","军士","左右","军马","主公","引兵","次日","大喜","天下","东吴","于是"&#125;words = jieba.lcut(txt)counts = &#123;&#125;for word in words: if len(word) == 1: continue elif word == "诸葛亮" or word == "孔明曰": rword = "孔明" elif word == "关公" or word == "云长": rword = "关羽" elif word == "玄德" or word == "玄德曰": rword = "刘备" elif word == "孟德" or word == "丞相": rword = "曹操" else: rword = word counts[rword] = counts.get(rword,0) + 1for word in excludes: del counts[word]items = list(counts.items())items.sort(key=lambda x:x[1], reverse=True)for i in range(10): word, count = items[i] print("&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;".format(word, count)) 资料下载 hamlet.txt/hamlet.txt) threekingdoms.txt/threekingdoms.txt)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵩天老师Python(1)基本语法元素]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%B5%A9%E5%A4%A9%E8%80%81%E5%B8%88Python(1)%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[程序设计语言编程语言种类很多，但生命力强劲的却不多 编程语言有超过600种，绝大部分都不再被使用 C语言诞生于1972年，它是第一个被广泛使用的编程语言 Python语言诞生于1990年，它是最流行最好用的编程语言 编译和解释计算机执行源程序的两种方式：编译和解释 编译:将源代码一次性转换成目标代码的过程 解释:将源代码逐条转换成目标代码同时逐条运行的过程 程序的基本编写方法IPO程序的基本编写方法 I：Input 输入，程序的输入 P：Process 处理，程序的主要逻辑 O：Output 输出，程序的输出 编程解决问题的步骤 分析问题：分析问题的计算部分，想清楚 划分边界：划分问题的功能边界，规划IPO 设计算法：设计问题的求解算法，关注算法 编写程序：编写问题的计算程序，编程序 调试测试：调试程序使正确运行，运行调试 升级维护：适应问题的升级维护，更新完善 历史Guido van Rossum ，Python语言创立者2002年，Python 2.x2008年，Python 3.x “温度转换”实例需求分析两种温度体系的转换 摄氏度转换为华氏度 华氏度转换为摄氏度 问题分析设计算法根据华氏和摄氏温度定义，利用转换公式如下：C = ( F – 32 ) / 1.8F = C * 1.8 + 32其中， C表示摄氏温度， F表示华氏温度 代码实现1234567891011#TempConvert.pyTempStr = input("请输入带有符号的温度值: ")if TempStr[-1] in ['F', 'f']: C = (eval(TempStr[0:-1]) - 32)/1.8 print("转换后的温度是&#123;:.2f&#125;C".format(C))elif TempStr[-1] in ['C', 'c']: F = 1.8*eval(TempStr[0:-1]) + 32 print("转换后的温度是&#123;:.2f&#125;F".format(F))else: print("输入格式错误") 语法元素缩进缩进表达程序的格式框架 严格明确：缩进是语法的一部分，缩进不正确程序运行错误 所属关系：表达代码间包含和层次关系的唯一手段 长度一致：程序内一致即可，一般用4个空格或1个TAB 注释不被程序执行的辅助性说明信息 单行注释：以#开头，其后内容为注释 1# 这里是单行注释 多行注释：以’’’开头和结尾 12''' 这是多行注释第一行这是多行注释第二行 ''' 保留字被编程语言内部定义并保留使用的标识符 Python语言有35个保留字(也叫关键字)if, elif, else, in 保留字是编程语言的基本单词，大小写敏感if 是保留字，If 是变量 保留字 and elif import raise global as else in return nonlocal assert except is try True break finally lambda while False class for not with None continue from or yield async def if pass del await 数据类型数据类型：字符串、整数、浮点数、列表 语句与函数赋值语句：由赋值符号构成的一行代码分支语句：由判断条件决定程序运行方向的语句函数：根据输入参数产生不同输出的功能过程 输入函数 input()从控制台获得用户输入的函数 输出函数 print()以字符形式向控制台输出结果的函数 评估函数 eval()去掉参数最外侧引号并执行余下语句的函数]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS客户端API]]></title>
    <url>%2F2019%2F04%2F04%2FHDFS%E5%AE%A2%E6%88%B7%E7%AB%AFAPI%2F</url>
    <content type="text"><![CDATA[手动导入需要用的jars，也可以使用maven。 1234567891011121314151617181920212223242526272829303132333435363738/** * HDFS的客户端api功能无非就是操作HDFS上的文件或文件夹 * * @author Administrator * */public class HdfsClientDemo &#123; FileSystem hdfsClient; @Before public void init() throws Exception &#123; Configuration conf = new Configuration(); conf.addResource("myconf.xml"); conf.set("dfs.replication", "2"); conf.set("dfs.blocksize", "32m"); // 创建一个HDFS客户端对象 hdfsClient = FileSystem.get(new URI("hdfs://hdp-nn-01:9000/"), conf, "root"); /** * 上传一个文件 */ @Test public void testPutFile() throws Exception &#123; hdfsClient.copyFromLocalFile(new Path("d:/jdk-8u191-linux-x64.tar.gz"), new Path("/jdk8.gz")); hdfsClient.close(); &#125; /** * 测试取文件 * * @throws Exception */ @Test public void testGetFile() throws Exception &#123; hdfsClient.copyToLocalFile(false, new Path("/jdk8.gz"), new Path("d:/"), true); hdfsClient.close(); &#125; 注意：HDFS客户端从HDFS上读取数据写入本地磁盘时，可以使用Hadoop自己开发的本地库操作，也可以使用java 的原生库来操作本地文件。 参数就是useRawLocalFileSystem，如果为true，则使用java原生库；false则使用Hadoop自己的本地库。如果要使用Hadoop的本地库来操作本地文件，要配置Hadoop在本地的环境。 123456789101112131415161718192021222324252627282930313233343536 /** * 文件夹创建 * * @throws Exception */ @Test public void testMkdir() throws Exception &#123; // 如果创建文件夹时，指定权限信息，但创建的结果并不会跟指定的信息完全一致，因为想指定的信息还会经过一个参数值的掩码运算 hdfsClient.mkdirs(new Path("/xxx/yyy"), new FsPermission((short) 777)); hdfsClient.close(); &#125; /** * 文件夹删除 * * @throws Exception */ @Test public void testDeldir() throws Exception &#123; hdfsClient.delete(new Path("/xxx"), true); hdfsClient.close(); &#125; /** * 文件夹重命名 * * @throws Exception */ @Test public void testRenamedir() throws Exception &#123; hdfsClient.rename(new Path("/xxx"), new Path("/ooo")); hdfsClient.close(); &#125;&#125;]]></content>
      <categories>
        <category>大数据开发</category>
      </categories>
      <tags>
        <tag>大数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS基本配置属性]]></title>
    <url>%2F2019%2F04%2F04%2FHDFS%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[块大小HDFS中存储的文件块的块大小，默认128M 参数：dfs.blocksize 默认：134217728 此参数用于客户端程序，也就是说，HDFS里面存储的文件块的块大小完全由客户端决定 副本数量HDFS中存储的文件快可以有多个副本，默认3个 参数：dfs.replication 默认：3 此参数用于客户端程序，也就是说，HDFS里面存储的文件块的副本数完全由客户端决定 为什么要默认3个？第一个副本：存在离客户端系统最近的一台DataNode上；第二个副本：存在跟上一台DataNode相同的机架的另一台DataNode上；第三个副本：存在另一个机架上的某台DataNode上 NameNode元数据存储目录元数据存储目录就是NameNode的工作目录，其位置由以下参数决定： 参数：dfs.namenode.name.dir 默认：file://${hadoop.tmp.dir}/dfs/name 此参数是给服务端程序NameNode使用 此参数默认值在生产中并不合适，应该给NameNode专门配置一个安全的位置作为工作目录 正确做法：应该给NameNode配置多个目录，而且这多个目录应该挂载不同的磁盘1234&lt;property&gt;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;&lt;value&gt;/mnt/disk1,/mnt/disk2,/mnt/disk3,nfs://&lt;/value&gt;&lt;/property&gt; 配置多个目录后，NameNode会往个目录中写入==相同的数据==作为冗余备份 DataNode文件块存储目录DataNode的工作目录也是参数可配的： 参数：dfs.datanode.data.dir 默认：file://${hadoop.tmp.dir}/dfs/data 默认配置在生产系统中并不合适，应该让DataNode的工作目录指定到服务器上用于存储数据的多块数据磁盘上1234&lt;property&gt;&lt;name&gt;dfs.datanode.name.dir&lt;/name&gt;&lt;value&gt;/data/disk1,/data/disk2,/data/disk3&lt;/value&gt;&lt;/property&gt; 配置多个目录后，NameNode会往个目录中写入==不同的数据==，以扩大DataNode自身的容量 HDFS动态扩容扩容就是增加DataNode，DataNode可以在线扩容。 步骤 准备一台服务器，配置好环境：网络、IP、防火墙、免密登录、JDK； 从原集群的任意一台机器上复制Hadoop安装包到新机器上； 在原集群的slaves文件中添加新机器的主机名； 在新机器上启动DataNode即可。 DataNode启动方法 直接用start-dfs.sh 在新机器上手动启动一个DataNode进程：hadoop-daemon.sh start datanode]]></content>
      <categories>
        <category>大数据开发</category>
      </categories>
      <tags>
        <tag>大数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flume+Kafka实时数据采集]]></title>
    <url>%2F2019%2F04%2F04%2FFlume-Kafka%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Flume的配置 12345678910111213141516171819# avro-memory-kafka.confavro-memory-kafka.sources = avro-sourceavro-memory-kafka.sinks = kafka-sinkavro-memory-kafka.channels = memory-channelavro-memory-kafka.sources.avro-source.type = avroavro-memory-kafka.sources.avro-source.bind = bigdata-01avro-memory-kafka.sources.avro-source.port = 44444avro-memory-kafka.sinks.kafka-sink.type = org.apache.flume.sink.kafka.KafkaSinkavro-memory-kafka.sinks.kafka-sink.brokerList = bigdata-01:9092avro-memory-kafka.sinks.kafka-sink.topic = hello_topicavro-memory-kafka.sinks.kafka-sink.batchSize = 5avro-memory-kafka.sinks.kafka-sink.requiredAcks = 1avro-memory-kafka.channels.memory-channel.type = memoryavro-memory-kafka.sources.avro-source.channels = memory-channelavro-memory-kafka.sinks.kafka-sink.channel = memory-channel 启动Flume1234567891011flume-ng agent \--name avro-memory-kafka \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/avro-memory-kafka.conf \-Dflume.root.logger=INFO,consoleflume-ng agent \--name exec-memory-avro \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/exec-memory-avro.conf \-Dflume.root.logger=INFO,console 启动消费者进行监控1kafka-console-consumer.sh --zookeeper bigdata-01:2181 -topic hello_topic 向日志文件中追加内容123456789[root@bigdata-01 ~]# cd data/[root@bigdata-01 data]# lltotal 4-rw-r--r--. 1 root root 112 Feb 6 05:37 data.log[root@bigdata-01 data]# echo hellospark &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark2 &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark3 &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark4 &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark5 &gt;&gt; data.log 这时，消费者就可以消费到日志文件中的新内容了。 Flume的版本不同，配置文件（*.conf）需要配置的内容也不完全相同。]]></content>
      <categories>
        <category>大数据开发</category>
      </categories>
      <tags>
        <tag>大数据开发</tag>
      </tags>
  </entry>
</search>
