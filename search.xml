<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test password]]></title>
    <url>%2F2019%2F04%2F04%2Ftest-password%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python实现照片的手绘效果]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E5%AE%9E%E7%8E%B0%E7%85%A7%E7%89%87%E7%9A%84%E6%89%8B%E7%BB%98%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[梯度的重构利用像素之间的梯度值和虚拟深度值对图像进行重构，根据灰度变化来模拟人类视觉的明暗程度。 手绘效果的特征 黑白灰色 边界线条较重 相同或相近色彩趋于白色 略有光源效果 代码实现用到的第三方库安装：pip install pillow`pip install numpy` 1234567891011121314151617181920212223242526272829#image.pyfrom PIL import Imageimport numpy as npa = np.asarray(Image.open('./yunwuyue.jpg').convert('L')).astype('float')depth = 10. #预设深度值为10，取值范围0-100grad = np.gradient(a) #提取x和y方向的梯度值grad_x, grad_y = grad#根据深度值调整x和y方向的梯度值grad_x = grad_x * depth / 100.grad_y = grad_y * depth / 100.A = np.sqrt(grad_x**2 + grad_y**2 + 1.)uni_x = grad_x / Auni_y = grad_y / Auni_z = 1. / Avec_el = np.pi / 2.2vec_az = np.pi / 4dx = np.cos(vec_el) * np.cos(vec_az)dy = np.cos(vec_el) * np.sin(vec_az)dz = np.sin(vec_el)b = 255 * (dx * uni_x + dy * uni_y + dz * uni_z)b = b.clip(0, 255)im = Image.fromarray(b.astype('uint8'))im.save('./yunwuyueHD.jpg') 展示]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib绘制引力波]]></title>
    <url>%2F2019%2F04%2F04%2FMatplotlib%E7%BB%98%E5%88%B6%E5%BC%95%E5%8A%9B%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[2016年6月16日，LIGO合作组宣布2015年12月26日 03:38:53（UTC），两台不同位置的引力波探测器同时探测到了一个引力波信号。 引力波物理学中，引力波是因为时空弯曲对外以辐射形式传播的能量。爱因斯坦基于广义相对论语言了引力波的存在。2016年6月16日，LIGO合作组宣布2015年12月26日 03:38:53（UTC），两台不同位置的引力波探测器同时探测到了一个引力波信号。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-"""Created on Sun Feb 24 10:17:31 2019@author: Administrator"""#引力波import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile#产生时间序列rate_h, hstrain = wavfile.read(r"H1_Strain.wav","rb")rate_l, lstrain = wavfile.read(r"L1_Strain.wav","rb")reftime, ref_H1 = np.genfromtxt('wf_template.txt').transpose()#读取应变数据htime_interval = 1 / rate_hltime_interval = 1 / rate_lhtime_len = hstrain.shape[0] / rate_hhtime = np.arange(-htime_len / 2, htime_len / 2, htime_interval)ltime_len = lstrain.shape[0] / rate_lltime = np.arange(-ltime_len / 2, ltime_len / 2, ltime_interval)#使用来自“H1”探测器的数据作图fig = plt.figure(figsize = (12, 6)) #创建一个12*6的绘图空间plth = fig.add_subplot(221)plth.plot(htime, hstrain, 'y')plth.set_xlabel('Time(seconds)')plth.set_ylabel('H1 Strain')plth.set_title('H1 Strain')#绘制L1 Strain 和 Templatepltl = fig.add_subplot(222)pltl.plot(ltime, lstrain, 'g')pltl.set_xlabel('Time(seconds)')pltl.set_ylabel('L1 Strain')pltl.set_title('L1 Strain')pltref = fig.add_subplot(212)pltref.plot(reftime, ref_H1, 'y')pltref.set_xlabel('Time(seconds)')pltref.set_ylabel('Template Strain')pltref.set_title('Template')#自动调整图像外部边缘fig.tight_layout()plt.savefig("Gravitational_Waves_Original.png")plt.show()plt.close(fig) 图像展示]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群搭建]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用虚拟机搭建集群时的必要工作。 修改网卡 关闭防火墙 修改主机名、映射关系 安装JDK，配置环境变量 时间同步、集群通信、免密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#修改网卡信息vi /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0TYPE=EthernetUUID=81c06473-0e58-4a5a-b4c4-35a2a853ab04ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.8.100NETMASK=255.255.255.0GATEWAY=192.168.8.1DNS1=192.168.8.1DNS2=114.114.114.114#重启生效service network restart#++++++++++++++++++++++++++++++++++++++++++++++++#关闭防火墙 service iptables stop chkconfig iptables off #++++++++++++++++++++++++++++++++++++++++++++++++#修改主机名 vi /etc/sysconfig/network #++++++++++++++++++++++++++++++++++++++++++++++++#修改映射关系 vi /etc/hosts #++++++++++++++++++++++++++++++++++++++++++++++++#环境变量 vi /etc/profile export JAVA_HOME=/root/app/jdk1.8.0_191 export PATH=$PATH:$JAVA_HOME/bin #source一下生效 source /etc/profile #++++++++++++++++++++++++++++++++++++++++++++++++#时间同步yum install ntpdate -yntpdate 0.asia.pool.ntp.org#++++++++++++++++++++++++++++++++++++++++++++++++#集群通信yum install openssh-clientsssh登陆，scp发送文件scp -r /etc/hosts bigdata-03:/etc/#免密登陆ssh-keygen -t rsa #生成公钥和私钥ssh-copy-id -i /root/.ssh/id_rsa.pub bigdata-03 #为需要进行免密的机器进行发送公钥（不要忘了给自己发）#++++++++++++++++++++++++++++++++++++++++++++++++]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式消息发布订阅系统Kafka]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9FKafka%2F</url>
    <content type="text"><![CDATA[Kafka概述 和消息系统类似 消息中间件：生产者和消费者 A distributed streaming platform Kafka架构和核心概念 Kafka is run as a cluster on one or more servers that can span multiple datacenters. The Kafka cluster stores streams of records in categories called topics. Each record consists of a key, a value, and a timestamp. 单节点单broker的Kafka部署及使用1234567# $KAFKA_HOME/config/server.propertiesbroker.id=0listeners=PLAINTEXT://:9092host.name=bigdata-01log.dirs=/root/app/tmp/kafka-logszookeeper.connect=bigdata-01:2181 启动kafka123bin/kafka-server-start.sh $KAFKA_HOME/config/server.propertiesUSAGE: /root/app/kafka_2.11-0.9.0.0/bin/kafka-server-start.sh [-daemon] server.properties [--override property=value]* 创建topic：zk1bin/kafka-topics.sh --create --zookeeper bigdata-01:2181 --replication-factor 1 --partitions 1 --topic hello_topic 查看所有topic1bin/kafka-topics.sh --list --zookeeper bigdata-01:2181 发送消息：broker1bin/kafka-console-producer.sh --broker-list bigdata-01:9092 --topic hello_topic 消费消息：zk1bin/kafka-console-consumer.sh --zookeeper bigdata-01:2181 -topic hello_topic 查看所有topic的详细信息：1kafka-topics.sh --describe --zookeeper bigdata-01:2181 查看指定topic的详细信息：1kafka-topics.sh --describe --zookeeper bigdata-01:2181 -topic hello_topic 单节点多broker的Kafka部署及使用123456789101112131415161718#配置多个配置文件server-1.propertiesserver-2.propertiesserver-3.properties#启动kafka-server-start.sh -daemon $KAFKA_HOME/config/server-1.properties &amp;kafka-server-start.sh -daemon $KAFKA_HOME/config/server-2.properties &amp;kafka-server-start.sh -daemon $KAFKA_HOME/config/server-3.properties &amp;#创建topicbin/kafka-topics.sh --create --zookeeper bigdata-01:2181 --replication-factor 3 --partitions 1 --topic my-replication-topic#启动一个生产者kafka-console-producer.sh --broker-list bigdata-01:9093,bigdata-01:9094，bigdata-01:9095 --topic my-replication-topic#启动一个消费者kafka-console-consumer.sh --zookeeper bigdata-01:2181 -topic my-replication-topic Kafka容错性测试12345[root@bigdata-01 ~]# kafka-topics.sh --describe --zookeeper bigdata-01:2181Topic:hello_topic PartitionCount:1 ReplicationFactor:1 Configs: Topic: hello_topic Partition: 0 Leader: 0 Replicas: 0 Isr: 0Topic:my-replication-topic PartitionCount:1 ReplicationFactor:3 Configs: Topic: my-replication-topic Partition: 0 Leader: 3 Replicas: 3,1,2 Isr: 3,1,2 此时leader为broker3，如果终止该进程，会发生什么呢？123456789101112131415[root@bigdata-01 ~]# jps -m2882 ConsoleConsumer --zookeeper bigdata-01:2181 -topic my-replication-topic2660 Kafka /root/app/kafka_2.11-0.9.0.0/config/server-3.properties2550 Kafka /root/app/kafka_2.11-0.9.0.0/config/server-1.properties2843 ConsoleProducer --broker-list bigdata-01:9093,bigdata-01:9094，bigdata-01:9095 --topic my-replication-topic2955 Jps -m1934 QuorumPeerMain /root/app/zookeeper-3.4.5-cdh5.7.0/bin/../conf/zoo.cfg[root@bigdata-01 ~]# kill -9 2550[root@bigdata-01 ~]# kill -9 2660[root@bigdata-01 ~]# kafka-topics.sh --describe --zookeeper bigdata-01:2181Topic:hello_topic PartitionCount:1 ReplicationFactor:1 Configs: Topic: hello_topic Partition: 0 Leader: 0 Replicas: 0 Isr: 0Topic:my-replication-topic PartitionCount:1 ReplicationFactor:3 Configs: Topic: my-replication-topic Partition: 0 Leader: 2 Replicas: 3,1,2 Isr: 2 发现杀掉broker1,3以后，选举2为leader，并不影响消息的发送和接收。 Kafka的Java API使用IDEA + Maven构建开发环境，pom.xml配置如下12345678910111213141516171819&lt;properties&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;kafka.version&gt;0.9.0.0&lt;/kafka.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--kafka dependency--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;$&#123;kafka.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 创建Kafka的配置类123456789/** * Kafka常用配置文件 */public class KafkaProperties &#123; public static final String ZK = "bigdata-01:2181"; public static final String TOPIC = "hello_topic"; public static final String BROKER_LIST = "bigdata-01:9092"; public static final String GROUP_ID = "test_group_1";&#125; Kafka的生产者12345678910111213141516171819202122232425262728293031323334353637import kafka.javaapi.producer.Producer;import kafka.producer.KeyedMessage;import kafka.producer.ProducerConfig;import java.util.Properties;/** * Kafka生产者 */public class KafkaProducer extends Thread&#123; private String topic; private Producer&lt;Integer,String&gt; producer; public KafkaProducer(String topic)&#123; this.topic = topic; Properties properties = new Properties(); properties.put("metadata.broker.list",KafkaProperties.BROKER_LIST); properties.put("serializer.class","kafka.serializer.StringEncoder"); properties.put("request.required.acks","1"); producer = new Producer&lt;Integer, String&gt;(new ProducerConfig(properties)); &#125; @Override public void run() &#123; int messageNo = 1; while (true)&#123; String message = "message_" + messageNo; producer.send(new KeyedMessage&lt;Integer, String&gt;(topic, message)); System.out.println("Sent: " + message); messageNo ++ ; try&#123; Thread.sleep(2000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Kafka的消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445import kafka.consumer.Consumer;import kafka.consumer.ConsumerConfig;import kafka.consumer.ConsumerIterator;import kafka.consumer.KafkaStream;import kafka.javaapi.consumer.ConsumerConnector;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Properties;import static com.wjx.spark.kafka.KafkaProperties.GROUP_ID;/** * Kafka消费者 */public class KafkaConsumer extends Thread&#123; private String topic; public KafkaConsumer(String topic)&#123; this.topic = topic; &#125; private ConsumerConnector createConnector()&#123; Properties properties = new Properties(); properties.put("zookeeper.connect",KafkaProperties.ZK); properties.put("group.id",KafkaProperties.GROUP_ID); return Consumer.createJavaConsumerConnector(new ConsumerConfig(properties)); &#125; @Override public void run() &#123; ConsumerConnector consumer = createConnector(); Map&lt;String,Integer&gt; topicCountMap = new HashMap&lt;String, Integer&gt;(); topicCountMap.put(topic, 1); //String:topic //List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt; 对应的数据流 Map&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt;&gt; messageStreams = consumer.createMessageStreams(topicCountMap); KafkaStream&lt;byte[], byte[]&gt; stream = messageStreams.get(topic).get(0);//获取每次接收到的数据 ConsumerIterator&lt;byte[], byte[]&gt; iterator = stream.iterator(); while (iterator.hasNext())&#123; String message = new String(iterator.next().message()); System.out.println("received: " + message); &#125; &#125;&#125; Kafka客户端启动测试123456789/** * Kafka Java API测试 */public class KafkaClientApp &#123; public static void main(String[] args) &#123; new KafkaProducer(KafkaProperties.TOPIC).start(); new KafkaConsumer(KafkaProperties.TOPIC).start(); &#125;&#125;]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式日志采集框架Flume]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E6%A1%86%E6%9E%B6Flume%2F</url>
    <content type="text"><![CDATA[Flume概述Flume is a distributed, reliable, and available service for efficiently collecting(收集), aggregating(聚合), and moving(移动) large amounts of log data. Flume官网：http://flume.apache.org/ FLume是一个分布式、高可靠、高可用的服务，用于分布式海量日志高效收集、聚合、移动系统。 设计目标 可靠性 扩展性 管理性 业界同类产品对比 Flume: Cloudera/Apache Java Scribe: Facebook C/C++ 不再维护 Chukwa: Yahoo/Apache Java 不再维护 Fluentd: Ruby Logstash: ELK(Elasticsearch,Kibana) Flume架构及核心组件 Source 收集 Channel 聚集 Sink 输出 Flume环境部署前置条件 Java Runtime Environment - Java 1.8 or later Memory - Sufficient memory for configurations used by sources, channels or sinks Disk Space - Sufficient disk space for configurations used by channels or sinks Directory Permissions - Read/Write permissions for directories used by agent 安装jdk下载解压到~/app将java配置到系统环境变量中：vi ~/.bash_profile123export JAVA_HOME=/root/app/jdk1.8.0_191export PATH=$JAVA_HOME/bin:$PATHsource ~/.bash_profile 检测：java -version 安装Flume下载解压到~/app将flume配置到系统环境变量中：123export FLUME_HOME=/root/app/apache-flume-1.6.0-cdh5.7.0-binexport PATH=$FLUME_HOME/bin:$PATHsource ~/.bash_profile flume-env.sh的配置：export JAVA_HOME=/root/app/jdk1.8.0_191检测：flume-ng version Flume实战需求1：从指定网络端口采集数据输出到控制台使用flume的关键就是写配置文件： 配置source 配置channel 配置sink 把以上3个组件串起来 配置文件1234567891011121314151617181920212223242526272829# example.conf: A single-node Flume configuration# a1:agent名称# r1:source名称# k1:sink名称# c1:channel名称# Name the components on this agenta1.sources = r1a1.sinks = k1a1.channels = c1# Describe/configure the sourcea1.sources.r1.type = netcata1.sources.r1.bind = localhosta1.sources.r1.port = 44444# Describe the sinka1.sinks.k1.type = logger# Use a channel which buffers events in memorya1.channels.c1.type = memory# a1.channels.c1.capacity = 1000# a1.channels.c1.transactionCapacity = 100# Bind the source and sink to the channela1.sources.r1.channels = c1a1.sinks.k1.channel = c1 启动agent12345flume-ng agent \--name a1 \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/example.conf \-Dflume.root.logger=INFO,console 使用telnet进行测试：telnet localhost 444441Event: &#123; headers:&#123;&#125; body: 68 65 6C 6C 6F 0D hello. &#125; Event是Flume数据传输的基本单元Event = 可选的header + byte array 需求2：监控一个文件实时采集新增的数据输出到控制台Agent选型：exec source + memory channel + logger sink 配置文件123456789101112131415161718192021222324# example.conf: A single-node Flume configuration# Name the components on this agenta1.sources = r1a1.sinks = k1a1.channels = c1# Describe/configure the sourcea1.sources.r1.type = execa1.sources.r1.command = tail -F /root/data/data.loga1.sources.r1.shell = /bin/bash -c# Describe the sinka1.sinks.k1.type = logger# Use a channel which buffers events in memorya1.channels.c1.type = memory# a1.channels.c1.capacity = 1000# a1.channels.c1.transactionCapacity = 100# Bind the source and sink to the channela1.sources.r1.channels = c1a1.sinks.k1.channel = c1 启动agent12345flume-ng agent \--name a1 \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/exec-memory-logger.conf \-Dflume.root.logger=INFO,console 需求3：将A服务器上的日志实时采集到B服务器技术选型：exec source + memory channel + avro sink avro source + memory channel + logger sink 配置文件1:exec-memory-avro.conf12345678910111213141516exec-memory-avro.sources = exec-sourceexec-memory-avro.sinks = avro-sinkexec-memory-avro.channels = memory-channelexec-memory-avro.sources.exec-source.type = execexec-memory-avro.sources.exec-source.command = tail -F /root/data/data.logexec-memory-avro.sources.exec-source.shell = /bin/bash -cexec-memory-avro.sinks.avro-sink.type = avroexec-memory-avro.sinks.avro-sink.hostname = bigdata-01exec-memory-avro.sinks.avro-sink.port = 44444exec-memory-avro.channels.memory-channel.type = memoryexec-memory-avro.sources.exec-source.channels = memory-channelexec-memory-avro.sinks.avro-sink.channel = memory-channel 配置文件2:avro-memory-logger.conf1234567891011121314avro-memory-logger.sources = avro-sourceavro-memory-logger.sinks = logger-sinkavro-memory-logger.channels = memory-channelavro-memory-logger.sources.avro-source.type = avroavro-memory-logger.sources.avro-source.bind = bigdata-01avro-memory-logger.sources.avro-source.port = 44444avro-memory-logger.sinks.logger-sink.type = loggeravro-memory-logger.channels.memory-channel.type = memoryavro-memory-logger.sources.avro-source.channels = memory-channelavro-memory-logger.sinks.logger-sink.channel = memory-channel 先启动avro-memory-logger12345flume-ng agent \--name avro-memory-logger \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/avro-memory-logger.conf \-Dflume.root.logger=INFO,console 再启动exec-memory-avro12345flume-ng agent \--name exec-memory-avro \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/exec-memory-avro.conf \-Dflume.root.logger=INFO,console 日志收集过程： 机器A上监控一个文件，当我们访问主站的时候，会有用户行为日志记录到access.log中 avro sink 把新产生的日志输出到对应的 avro source 指定的 hostname 和 port 上 通过 avro source 对应的 agent 将我们的日志输出到控制台(kafka)]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础语句复习]]></title>
    <url>%2F2019%2F04%2F04%2FSQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一些最重要的 SQL 命令 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL SELECT DISTINCT（选择不同） 语法SELECT DISTINCT语法用于仅返回不同的（different）值。在一张表内，一列通常包含许多重复的值; 有时你只想列出不同的（different）值。SELECT DISTINCT语句用于仅返回不同的（different）值。 12345678SELECT DISTINCT column1, column2, ...FROM table_name;/*实例*/SELECT DISTINCT Country FROM Customers;/*列出不同（distinct）客户国家的数量*/SELECT COUNT(DISTINCT Country) FROM Customers; SQL WHERE 语法1234567SELECT column1, column2, ...FROM table_nameWHERE condition;/*实例*/SELECT * FROM CustomersWHERE Country='Mexico'; WHERE子句中可以使用以下运算符： 运算符 描述 = 等于 &lt;&gt; 不等于。注意：在某些版本的SQL中，这个操作符可能写成!= > 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 为列指定多个可能的值 SQL AND &amp; OR 运算符WHERE子句可以与AND，OR和NOT运算符结合使用。 AND和OR运算符用于根据多个条件筛选记录： 如果由AND分隔的所有条件为TRUE，则AND运算符显示记录。 如果由OR分隔的任何条件为真，则OR运算符显示记录。 如果条件不为真，则NOT运算符显示记录。 12345678910111213141516/*实例*/SELECT * FROM Customers WHERE Country='Germany' AND City='Berlin';SELECT * FROM CustomersWHERE City='Berlin' OR City='München';SELECT * FROM CustomersWHERE NOT Country='Germany';SELECT * FROM CustomersWHERE Country='Germany' AND (City='Berlin' OR City='München');SELECT * FROM CustomersWHERE NOT Country='Germany' AND NOT Country='USA'; SQL ORDER BY Keyword（按关键字排序）SQL ORDER BY 关键字 ORDER BY 关键字用于按升序或降序对结果集进行排序。ORDER BY 关键字默认情况下按升序排序记录。如果需要按降序对记录进行排序，可以使用DESC关键字。 1234567891011121314SELECT column1, column2, ...FROM table_nameORDER BY column1, column2, ... ASC|DESC;/*ORDER BY 多列 实例*//*从 "Customers" 表中选取所有客户，并按照 "Country" 和 "CustomerName" 列排序*/SELECT * FROM CustomersORDER BY Country, CustomerName;/*从"Customers" 表中选择所有客户，按 "Country" 升序排列，并按 "CustomerName" 列降序排列*/SELECT * FROM CustomersORDER BY Country ASC, CustomerName DESC; SQL INSERT INTO 语句（在表中插入）SQL INSERT INTO 语句 INSERT INTO 语句用于向表中插入新记录。 SQL INSERT INTO 语法 INSERT INTO 语句可以用两种形式编写。第一个表单没有指定要插入数据的列的名称，只提供要插入的值：123456789INSERT INTO table_name (column1, column2, column3, ...)VALUES (value1, value2, value3, ...);/*实例*/INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)VALUES ('Cardinal','Tom B. Erichsen','Skagen 21','Stavanger','4006','Norway');INSERT INTO Customers (CustomerName, City, Country)VALUES ('Cardinal', 'Stavanger', 'Norway'); 如果要为表中的所有列添加值，则不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。123456INSERT INTO table_nameVALUES (value1, value2, value3, ...);/*实例*/INSERT INTO Customers VALUES ('Cardinal','Tom B. Erichsen','Skagen 21','Stavanger','4006','Norway'); SQL NULL Values（空值）如何测试NULL值？ 使用比较运算符（例如=，&lt;或&lt;&gt;）来测试NULL值是不可行的。我们将不得不使用IS NULL和IS NOT NULL运算符。 123456789/*IS NULL语法*/SELECT column_namesFROM table_nameWHERE column_name IS NULL;/*IS NOT NULL语法*/SELECT column_namesFROM table_nameWHERE column_name IS NOT NULL; SQL UPDATE 语句（更新表中的记录）UPDATE 语句用于更新表中已存在的记录。 1234567891011/*SQL UPDATE 语法*/UPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;/*实例*//*把国家/地区为"Mexico"的所有记录的联系人姓名更新为“Juan”*/UPDATE CustomersSET ContactName='Juan'WHERE Country='Mexico'; 更新记录时要小心。如果省略WHERE子句，所有记录将被更新！12UPDATE CustomersSET ContactName='Juan'; SQL Delete 语句（删除表中的记录）DELETE 语句用于删除表中的行。 1234/*SQL DELETE 语法*/DELETE FROM table_nameWHERE condition; WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！ 删除所有数据：可以删除表中的所有行，而不需要删除该表。这意味着表的结构、属性和索引将保持不变123DELETE FROM table_name;/*或者*/DELETE * FROM table_name;]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis操作]]></title>
    <url>%2F2019%2F04%2F04%2FRedis%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[环境准备：centOS6.5Redis是c语言开发的。安装redis需要c语言的编译环境。如果没有gcc需要在线安装。 安装编译环境yum install gcc-c++ 安装步骤 第一步：redis的源码(安装)包上传到linux系统。 第二步：进入到压缩包所在的路径，解压缩redis。 1tar -zxvf redis-3.0.0.tar.gz 第三步：编译。进入redis源码目录（redis3.0.0）。 执行：make 第四步：进入/usr/redis-3.0.0/src/安装。 1make install PREFIX=/usr/java/redis 如果报错123456zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directoryzmalloc.h:55:2: error: #error "Newer version of jemalloc required"make[1]: *** [adlist.o] Error 1make[1]: Leaving directory `/data0/src/redis-2.6.2/src'make: *** [all] Error 2 解决办法是：1make MALLOC=libc PREFIX参数指定redis的安装目录。一般软件安装到/usr目录下 连接redis redis的启动前端启动在redis的安装目录的bin目录下直接启动redis-server 1./redis-server 后台启动把/root/redis-3.0.0/redis.conf复制到/usr/java/redis/bin目录下 1cp redis.conf /usr/java/redis/bin/ 修改配置文件： 启动服务器： 1./redis-server redis.conf 查看redis进程： 1ps aux|grep redis 12root 5190 0.1 0.3 33936 1712 ? Ssl 18:23 0:00 ./redis-server *:6379 root 5196 0.0 0.1 4356 728 pts/0 S+ 18:24 0:00 grep redis 关闭服务1./redis-cli shutdown 或者通过kill -9 PID关闭 Redis-cli [root@localhost bin]# ./redis-cli 默认连接localhost运行在6379端口的redis服务。 [root@localhost bin]# ./redis-cli -h 192.168.75.128 -p 6379 -h：连接的服务器的地址 -p：服务的端口号 关闭redis：1./redis-cli shutdown]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析之Numpy库入门]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy%E5%BA%93%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[数据的维度一个数据表达一个含义一组数据表达一个或多个含义 一维数据一维数据由对等关系的有序或无序数据构成，采用线性方式组织，对应列表、数组和集合等概念。 列表和数组 列表：数据类型可以不同 数组：数据类型相同 二维数据二维数据由多个一维数据构成，是一维数据的组合形式。表格是典型的二维数据，其中，表头是二维数据的一部分。 多维数据多维数据由一维或二维数据在新维度上扩展形成。 高维数据高维数据仅利用最基本的二元关系展示数据间的复杂结构。12345678910&#123; “firstName” : “Tian” , “lastName” : “Song” , “address” : &#123; “streetAddr” : “中关村南大街5号” , “city” : “北京市” , “zipcode” : “100081” &#125; , “prof” : [ “Computer System” , “Security” ]&#125; 数据维度的Python表示数据维度是数据的组织形式。 一维数据：列表和集合类型 二维数据：列表类型 多维数据：列表类型 高维数据：字典类型或数据表示格式(JSON、XML和YAML格式) NumPy的数组对象：ndarrayNumPyNumPy是一个开源的Python科学计算基础库，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合C/C++/Fortran代码的工具 线性代数、傅里叶变换、随机数生成等功能NumPy是SciPy、Pandas等数据处理或科学计算库的基础。 NumPy的引用尽管别名可以省略或更改，建议使用上述约定的别名 N维数组对象：ndarrayPython已有列表类型，为什么需要一个数组对象(类型)？ 数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数 设置专门的数组对象，经过优化，可以提升这类应用的运算速度 观察：科学计算中，一个维度所有数据的类型往往相同 数组对象采用相同的数据类型，有助于节省运算和存储 ndarray是一个多维数组对象，由两部分构成： 实际的数据 描述这些数据的元数据（数据维度、数据类型等）ndarray数组一般要求所有元素类型相同（同质），数组下标从0开始 ndarray实例123np.array() #生成一个ndarray数组#np.array()输出成[]形式，元素由空格分割#轴(axis): 保存数据的维度；秩(rank)：轴的数量 ndarray对象的属性 属性 说明 .ndim 秩，即轴的数量或维度的数量 .shape ndarray对象的尺度，对于矩阵，n行m列 .size ndarray对象元素的个数，相当于.shape中n*m的值 .dtype ndarray对象的元素类型 .itemsize ndarray对象中每个元素的大小，以字节为单位 ndarray数组的元素ndarray的元素类型(1) 数据类型 说明 bool 布尔类型，True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数，与C语言中ssize_t一致，int32或int64 int8 字节长度的整数，取值：[‐128, 127] int16 16位长度的整数，取值：[‐32768, 32767] int32 32位长度的整数，取值：[‐2^31,2^31‐1] int64 64位长度的整数，取值：[‐2^63,2^63‐1] ndarray的元素类型(2) 数据类型 说明 uint8 8位无符号整数，取值：[0, 255] uint16 16位无符号整数，取值：[0, 65535] uint32 32位无符号整数，取值：[0,232‐1] uint6 32位无符号整数，取值：[0,264‐1] float16 16位半精度浮点数：1位符号位，5位指数，10位尾数 float32 32位半精度浮点数：1位符号位，8位指数，23位尾数 float64 64位半精度浮点数：1位符号位，11位指数，52位尾数 ndarray的元素类型(3) 数据类型 说明 complex64 复数类型，实部和虚部都是32位浮点数 complex128 复数类型，实部和虚部都是64位浮点数 ndarray为什么要支持这么多种元素类型？ 对比：Python语法仅支持整数、浮点数和复数3种类型 科学计算涉及数据较多，对存储和性能都有较高要求 对元素类型精细定义，有助于NumPy合理使用存储空间并优化性能 对元素类型精细定义，有助于程序员对程序规模有合理评估 非同质的ndarray对象 ndarray数组可以由非同质对象构成 非同质ndarray元素为对象类型 非同质ndarray对象无法有效发挥NumPy优势，尽量避免 ndarray数组的创建ndarray数组的创建方法 从Python中的列表、元组等类型创建ndarray数组 使用NumPy中函数创建ndarray数组，如：arange, ones, zero （1）从Python中的列表、元组等类型创建ndarray数组123x= np.array(list/tuple)x= np.array(list/tuple, dtype=np.float32)#当np.array()不指定dtype时，NumPy将根据数据情况关联一个dtype 12345678#从列表类型创建x = np.array([0, 1, 2, 3])#从元组类型创建x = np.array((4, 5, 6, 7))#从列表和元组混合类型创建x = np.array([[1, 2], [9, 8], (0.1, 0.2)]) （2）使用NumPy中函数创建ndarray数组，如：arange, ones, zero等 函数 说明 np.arange(n) 类似range()函数，返回ndarray类型，元素从0到n‐1 np.ones(shape) 根据shape生成一个全1数组，shape是元组类型 np.zeros(shape) 根据shape生成一个全0数组，shape是元组类型 np.full(shape,val) 根据shape生成一个数组，每个元素值都是valnp.eye(n)创建一个正方的n*n单位矩阵，对角线为1，其余为0 np.ones_like(a) 根据数组a的形状生成一个全1数组 np.zeros_like(a) 根据数组a的形状生成一个全0数组 np.full_like(a,val) 根据数组a的形状生成一个数组，每个元素值都是val （3）使用NumPy中其他函数创建ndarray数组 函数 说明 np.linspace() 根据起止数据等间距地填充数据，形成数组 np.concatenate() 将两个或多个数组合并成一个新的 ndarray数组的变换对于创建后的ndarray数组，可以对其进行维度变换和元素类型变换 ndarray数组的维度变换 方法 说明 .reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 .resize(shape) 与.reshape()功能一致，但修改原数组 .swapaxes(ax1,ax2) 将数组n个维度中两个维度进行调换 .flatten() 对数组进行降维，返回折叠后的一维数组，原数组不变 ndarray数组的类型变换1new_a = a.astype(new_type) astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致。 ndarray数组向列表的转换1ls = a.tolist() ndarray数组的操作数组的索引和切片 索引：获取数组中特定位置元素的过程 切片：获取数组元素子集的过程 一维数组的索引和切片123456789In [7]: a = np.array([9,8,7,6,5])In [8]: a[2]Out[8]: 7#起始编号: 终止编号(不含): 步长，3元素冒号分割#编号0开始从左递增，或‐1开始从右递减In [9]: a[1:4:2]Out[9]: array([8, 6]) 多维数组的索引和切片多维数组的索引：每个维度一个索引值，逗号分割 1234567891011121314151617181920In [10]: a = np.arange(24).reshape((2,3,4))In [11]: aOut[11]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])In [12]: a[1,2,3]Out[12]: 23In [13]: a[0,1,2]Out[13]: 6In [14]: a[-1,-2,-3]Out[14]: 17 多维数组的切片： 选取一个维度用”:”,每个维度切片方法与一维数组相同,每个维度可以使用步长跳跃切片。 12345678910111213141516171819202122#In [10]: a = np.arange(24).reshape((2,3,4))In [15]: a[:,1,-3]Out[15]: array([ 5, 17])In [16]: a[:,1:3,:]Out[16]: array([[[ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[16, 17, 18, 19], [20, 21, 22, 23]]])In [17]: a[:,:,::2]Out[17]: array([[[ 0, 2], [ 4, 6], [ 8, 10]], [[12, 14], [16, 18], [20, 22]]]) ndarray数组的运算数组与标量之间的运算数组与标量之间的运算作用于数组的每一个元素 1234567891011121314151617181920212223242526In [19]: a = np.arange(24).reshape((2,3,4))In [20]: aOut[20]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])In [21]: a.mean()Out[21]: 11.5In [22]: a = a / a.mean()In [23]: aOut[23]: array([[[0. , 0.08695652, 0.17391304, 0.26086957], [0.34782609, 0.43478261, 0.52173913, 0.60869565], [0.69565217, 0.7826087 , 0.86956522, 0.95652174]], [[1.04347826, 1.13043478, 1.2173913 , 1.30434783], [1.39130435, 1.47826087, 1.56521739, 1.65217391], [1.73913043, 1.82608696, 1.91304348, 2. ]]]) NumPy一元函数对ndarray中的数据执行元素级运算的函数 函数 说明 np.abs(x) np.fabs(x) 计算数组各元素的绝对值 np.sqrt(x) 计算数组各元素的平方根 np.square(x) 计算数组各元素的平方 np.log(x) np.log10(x) np.log2(x) 计算数组各元素的自然对数、10底对数和2底对数 np.ceil(x) np.floor(x) 计算数组各元素的ceiling值 或 floor值 np.rint(x) 计算数组各元素的四舍五入值 np.modf(x) 将数组各元素的小数和整数部分以两个独立数组形式返回 np.cos(x) np.cosh(x) np.sin(x) np.sinh(x) np.tan(x) np.tanh(x) 计算数组各元素的普通型和双曲型三角函数 np.exp(x) 计算数组各元素的指数值 np.sign(x) 计算数组各元素的符号值，1(+), 0,-1(-) 12345678910111213141516171819202122232425262728293031323334353637383940In [24]: a = np.arange(24).reshape((2,3,4))In [25]: np.square(a)Out[25]: array([[[ 0, 1, 4, 9], [ 16, 25, 36, 49], [ 64, 81, 100, 121]], [[144, 169, 196, 225], [256, 289, 324, 361], [400, 441, 484, 529]]], dtype=int32)In [26]: a = np.sqrt(a)In [27]: aOut[27]: array([[[0. , 1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974, 2.64575131], [2.82842712, 3. , 3.16227766, 3.31662479]], [[3.46410162, 3.60555128, 3.74165739, 3.87298335], [4. , 4.12310563, 4.24264069, 4.35889894], [4.47213595, 4.58257569, 4.69041576, 4.79583152]]])In [28]: np.modf(a)Out[28]: (array([[[0. , 0. , 0.41421356, 0.73205081], [0. , 0.23606798, 0.44948974, 0.64575131], [0.82842712, 0. , 0.16227766, 0.31662479]], [[0.46410162, 0.60555128, 0.74165739, 0.87298335], [0. , 0.12310563, 0.24264069, 0.35889894], [0.47213595, 0.58257569, 0.69041576, 0.79583152]]]), array([[[0., 1., 1., 1.], [2., 2., 2., 2.], [2., 3., 3., 3.]], [[3., 3., 3., 3.], [4., 4., 4., 4.], [4., 4., 4., 4.]]])) NumPy二元函数 函数 说明 + ‐ * / ** 两个数组各元素进行对应运算 np.maximum(x,y) np.fmax() np.minimum(x,y) np.fmin() 元素级的最大值/最小值计算 np.mod(x,y) 元素级的模运算 np.copysign(x,y) 将数组y中各元素值的符号赋值给数组x对应元素 &gt;&lt; &gt;= &lt;= == != 算术比较，产生布尔型数组 12345678910111213141516171819202122232425262728293031323334353637383940414243In [29]: a = np.arange(24).reshape((2,3,4))In [30]: b = np.sqrt(a)In [31]: aOut[31]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])In [32]: bOut[32]: array([[[0. , 1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974, 2.64575131], [2.82842712, 3. , 3.16227766, 3.31662479]], [[3.46410162, 3.60555128, 3.74165739, 3.87298335], [4. , 4.12310563, 4.24264069, 4.35889894], [4.47213595, 4.58257569, 4.69041576, 4.79583152]]])In [33]: np.maximum(a,b)Out[33]: array([[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]], [[12., 13., 14., 15.], [16., 17., 18., 19.], [20., 21., 22., 23.]]])In [34]: a &gt; bOut[34]: array([[[False, False, True, True], [ True, True, True, True], [ True, True, True, True]], [[ True, True, True, True], [ True, True, True, True], [ True, True, True, True]]])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python(9)Python计算生态]]></title>
    <url>%2F2019%2F04%2F04%2Fpython-9-Python%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81%2F</url>
    <content type="text"><![CDATA[从数据处理到人工智能数据表示-&gt;数据清洗-&gt;数据统计-&gt;数据可视化-&gt;数据挖掘-&gt;人工智能 数据表示：采用合适方式用程序表达数据 数据清理：数据归一化、数据转换、异常值处理 数据统计：数据的概要理解，数量、分布、中位数等 数据可视化：直观展示数据内涵的方式 数据挖掘：从数据分析获得知识，产生数据外的价值 人工智能：数据/语言/图像/视觉等方面深度分析与决策 Python库之数据分析Numpy: 表达N维数组的最基础库 Python接口使用，C语言实现，计算速度优异 Python数据分析及科学计算的基础库，支撑Pandas等 提供直接的矩阵运算、广播函数、线性代数等功能 Pandas: Python数据分析高层次应用库 提供了简单易用的数据结构和数据分析工具 理解数据类型与索引的关系，操作索引即操作数据 Python最主要的数据分析功能库，基于Numpy开发 Series = 索引 + 一维数据DataFrame = 行列索引 + 二维数据 SciPy: 数学、科学和工程计算功能库 提供了一批数学算法及工程数据运算功能 类似Matlab，可用于如傅里叶变换、信号处理等应用 Python最主要的科学计算功能库，基于Numpy开发 Python库之数据可视化Matplotlib: 高质量的二维数据可视化功能库 提供了超过100种数据可视化展示效果 通过matplotlib.pyplot子库调用各可视化效果 Python最主要的数据可视化功能库，基于Numpy开发 Seaborn: 统计类数据可视化功能库 提供了一批高层次的统计类数据可视化展示效果 主要展示数据间分布、分类和线性关系等内容 基于Matplotlib开发，支持Numpy和Pandas Mayavi：三维科学数据可视化功能库 提供了一批简单易用的3D科学计算数据可视化展示效果 目前版本是Mayavi2，三维可视化最主要的第三方库 支持Numpy、TVTK、Traits、Envisage等第三方库 Python之文本处理PyPDF2：用来处理pdf文件的工具集 提供了一批处理PDF文件的计算功能 支持获取信息、分隔/整合文件、加密解密等 完全Python语言实现，不需要额外依赖，功能稳定 12345678from PyPDF2 import PdfFileReader, PdfFileMergermerger = PdfFileMerger()input1 = open("document1.pdf", "rb")input2 = open("document2.pdf", "rb")merger.append(fileobj = input1, pages = (0,3))merger.merge(position = 2, fileobj = input2, pages = (0,1))output = open("document-output.pdf", "wb")merger.write(output) NLTK：自然语言文本处理第三方库 提供了一批简单易用的自然语言文本处理功能 支持语言文本分类、标记、语法句法、语义分析等 最优秀的Python自然语言处理库 123from nltk.corpus import treebankt = treebank.parsed_sents('wsj_0001.mrg')[0]t.draw() Python-docx：创建或更新Microsoft Word文件的第三方库 提供创建或更新.doc .docx等文件的计算功能 增加并配置段落、图片、表格、文字等，功能全面 123456from docx import Documentdocument = Document()document.add_heading('Document Title', 0)p = document.add_paragraph('A plain paragraph having some ')document.add_page_break()document.save('demo.docx') Python之机器学习Scikit-learn：机器学习方法工具集 提供一批统一化的机器学习方法功能接口 提供聚类、分类、回归、强化学习等计算功能 机器学习最基本且最优秀的Python第三方库 TensorFlow：AlphaGo背后的机器学习计算框架 谷歌公司推动的开源机器学习框架 将数据流图作为基础，图节点代表运算，边代表张量 应用机器学习方法的一种方式，支撑谷歌人工智能应用 123456import tensorflow as tfinit = tf.global_variables_initializer()sess = tf.Session()sess.run(init)res = sess.run(result)print('result:', res) MXNet：基于神经网络的深度学习计算框架 提供可扩展的神经网络及深度学习计算功能 可用于自动驾驶、机器翻译、语音识别等众多领域 Python最重要的深度学习计算框架 实例：霍兰德人格分析雷达图问题分析霍兰德人格分析 霍兰德认为：人格兴趣与职业之间应有一种内在的对应关系 人格分类：研究型、艺术型、社会型、企业型、传统型、现实性 职业：工程师、实验员、艺术家、推销员、记事员、社会工作者 需求 需求：雷达图方式验证霍兰德人格分析 输入：各职业人群结合兴趣的调研数据 输出：雷达图 第三方库的使用 通用雷达图绘制：matplotlib库 专业的多维数据表示：numpy库 输出：雷达图 代码12345678910111213141516171819202122232425262728#HollandRadarDraw.pyimport numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams['font.family']='SimHei'radar_labels = np.array(['研究型(I)','艺术型(A)','社会型(S)',\'企业型(E)','常规型(C)','现实型(R)'])data = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],[0.85, 0.35, 0.30, 0.40, 0.40, 0.30],[0.43, 0.89, 0.30, 0.28, 0.22, 0.30],[0.30, 0.25, 0.48, 0.85, 0.45, 0.40],[0.20, 0.38, 0.87, 0.45, 0.32, 0.28],[0.34, 0.31, 0.38, 0.40, 0.92, 0.28]]) #数据值data_labels = ('艺术家','实验员','工程师','推销员','社会工作者','记事员')angles = np.linspace(0, 2*np.pi, 6, endpoint=False)data = np.concatenate((data, [data[0]]))angles = np.concatenate((angles, [angles[0]]))fig = plt.figure(facecolor="white")plt.subplot(111, polar=True)plt.plot(angles,data,'o-', linewidth=1, alpha=0.2)plt.fill(angles,data, alpha=0.25)plt.thetagrids(angles*180/np.pi, radar_labels,frac = 1.2)plt.figtext(0.52, 0.95, '霍兰德人格分析', ha='center', size=20)legend = plt.legend(data_labels, loc=(0.94, 0.80), labelspacing=0.1)plt.setp(legend.get_texts(), fontsize='large')plt.grid(True)plt.savefig('holland_radar.jpg')plt.show() 从Web解析到网络空间Python库之网络爬虫Requests: 最友好的网络爬虫功能库 提供了简单易用的类HTTP协议网络爬虫功能 支持连接池、SSL、Cookies、HTTP(S)代理等 Python最主要的页面级网络爬虫功能库 Scrapy: 优秀的网络爬虫框架 提供了构建网络爬虫系统的框架功能，功能半成品 支持批量和定时网页爬取、提供数据处理流程等 Python最主要且最专业的网络爬虫框架 pyspider: 强大的Web页面爬取系统 提供了完整的网页爬取系统构建功能 支持数据库后端、消息队列、优先级、分布式架构等 Python重要的网络爬虫类第三方库 Python库之Web信息提取Beautiful Soup: HTML和XML的解析库 提供了解析HTML和XML等Web信息的功能 又名beautifulsoup4或bs4，可以加载多种解析引擎 常与网络爬虫库搭配使用，如Scrapy、requests等 Re: 正则表达式解析和处理功能库 提供了定义和解析正则表达式的一批通用功能 可用于各类场景，包括定点的Web信息提取 Python最主要的标准库之一，无需安装 Python-Goose: 提取文章类型Web页面的功能库 提供了对Web页面中文章信息/视频等元数据的提取功能 针对特定类型Web页面，应用覆盖面较广 Python最主要的Web信息提取库 Python库之Web网站开发Django: 最流行的Web应用框架 提供了构建Web系统的基本应用框架 MTV模式：模型(model)、模板(Template)、视图(Views) Python最重要的Web应用框架，略微复杂的应用框架 Pyramid: 规模适中的Web应用框架 提供了简单方便构建Web系统的应用框架 不大不小，规模适中，适合快速构建并适度扩展类应用 Python产品级Web应用框架，起步简单可扩展性好 Flask: Web应用开发微框架 提供了最简单构建Web系统的应用框架 特点是：简单、规模小、快速 Django &gt; Pyramid &gt; Flask Python库之网络应用开发WeRoBot: 微信公众号开发框架 提供了解析微信服务器消息及反馈消息的功能 建立微信机器人的重要技术手段 aip: 百度AI开放平台接口 提供了访问百度AI服务的Python功能接口 语音、人脸、OCR、NLP、知识图谱、图像搜索等领域 Python百度AI应用的最主要方式 MyQR: 二维码生成第三方库 提供了生成二维码的系列功能 基本二维码、艺术二维码和动态二维码 从人机交互到艺术设计Python库之图形用户界面PyQt5: Qt开发框架的Python接口 提供了创建Qt5程序的Python API接口 Qt是非常成熟的跨平台桌面应用开发系统，完备GUI 推荐的Python GUI开发第三方库 wxPython: 跨平台GUI开发框架 提供了专用于Python的跨平台GUI开发框架 理解数据类型与索引的关系，操作索引即操作数据 Python最主要的数据分析功能库，基于Numpy开发 PyGObject: 使用GTK+开发GUI的功能库 提供了整合GTK+、WebKitGTK+等库的功能 GTK+：跨平台的一种用户图形界面GUI框架 实例：Anaconda采用该库构建GUI Python库之游戏开发PyGame: 简单的游戏开发功能库 提供了基于SDL的简单游戏开发功能及实现引擎 理解游戏对外部输入的响应机制及角色构建和交互机制 Python游戏入门最主要的第三方库 Panda3D: 开源、跨平台的3D渲染和游戏开发库 一个3D游戏引擎，提供Python和C++两种接口 支持很多先进特性：法线贴图、光泽贴图、卡通渲染等 由迪士尼和卡尼基梅隆大学共同开发 cocos2d: 构建2D游戏和图形界面交互式应用的框架 提供了基于OpenGL的游戏开发图形渲染功能 支持GPU加速，采用树形结构分层管理游戏对象类型 适用于2D专业级游戏开发 Python库之虚拟现实VR Zero: 在树莓派上开发VR应用的Python库 提供大量与VR开发相关的功能 针对树莓派的VR开发库，支持设备小型化，配置简单化 非常适合初学者实践VR开发及应用 pyovr: Oculus Rift的Python开发接口 针对Oculus VR设备的Python开发库 基于成熟的VR设备，提供全套文档，工业级应用设备 Python+虚拟现实领域探索的一种思路 Vizard: 基于Python的通用VR开发引擎 专业的企业级虚拟现实开发引擎 提供详细的官方文档 支持多种主流的VR硬件设备，具有一定通用性 Python库之图形艺术Quads: 迭代的艺术 对图片进行四分迭代，形成像素风 可以生成动图或静图图像 简单易用，具有很高展示度 ascii_art: ASCII艺术库 将普通图片转为ASCII艺术风格 输出可以是纯文本或彩色文本 可采用图片格式输出 实例: 玫瑰花绘制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# RoseDraw.pyimport turtle as t# 定义一个曲线绘制函数def DegreeCurve(n, r, d=1): for i in range(n): t.left(d) t.circle(r, abs(d))# 初始位置设定s = 0.2 # sizet.setup(450*5*s, 750*5*s)t.pencolor("black")t.fillcolor("red")t.speed(100)t.penup()t.goto(0, 900*s)t.pendown()# 绘制花朵形状t.begin_fill()t.circle(200*s,30)DegreeCurve(60, 50*s)t.circle(200*s,30)DegreeCurve(4, 100*s)t.circle(200*s,50)DegreeCurve(50, 50*s)t.circle(350*s,65)DegreeCurve(40, 70*s)t.circle(150*s,50)DegreeCurve(20, 50*s, -1)t.circle(400*s,60)DegreeCurve(18, 50*s)t.fd(250*s)t.right(150)t.circle(-500*s,12)t.left(140)t.circle(550*s,110)t.left(27)t.circle(650*s,100)t.left(130)t.circle(-300*s,20)t.right(123)t.circle(220*s,57)t.end_fill()# 绘制花枝形状t.left(120)t.fd(280*s)t.left(115)t.circle(300*s,33)t.left(180)t.circle(-300*s,33)DegreeCurve(70, 225*s, -1)t.circle(350*s,104)t.left(90)t.circle(200*s,105)t.circle(-500*s,63)t.penup()t.goto(170*s,-30*s)t.pendown()t.left(160)DegreeCurve(20, 2500*s)DegreeCurve(220, 250*s, -1)# 绘制一个绿色叶子t.fillcolor('green')t.penup()t.goto(670*s,-180*s)t.pendown()t.right(140)t.begin_fill()t.circle(300*s,120)t.left(60)t.circle(300*s,120)t.end_fill()t.penup()t.goto(180*s,-550*s)t.pendown()t.right(85)t.circle(600*s,40)# 绘制另一个绿色叶子t.penup()t.goto(-150*s,-1000*s)t.pendown()t.begin_fill()t.rt(120)t.circle(300*s,115)t.left(75)t.circle(300*s,100)t.end_fill()t.penup()t.goto(430*s,-1070*s)t.pendown()t.right(30)t.circle(-600*s,35)t.done()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python(8)程序设计方法学]]></title>
    <url>%2F2019%2F04%2F04%2Fpython-8-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[实例：体育竞技分析 高手过招，胜负只在毫厘之间 “体育竞技分析”问题分析体育竞技分析 需求：毫厘是多少？如何科学分析体育竞技比赛？ 输入：球员的水平 输出：可预测的比赛成绩 体育竞技分析：模拟N场比赛 计算思维：抽象 + 自动化 模拟：抽象比赛过程 + 自动化执行N场比赛 当N越大时，比赛结果分析会越科学 比赛规则 双人击球比赛：A &amp; B，回合制，5局3胜 开始时一方先发球，直至判分，接下来胜者发球 球员只能在发球局得分，15分胜一局 自顶向下和自底向上自顶向下（设计）——解决复杂问题的有效方法 将一个总问题表达为若干个小问题组成的形式 使用同样方法进一步分解小问题 直至，小问题可以用计算机简单明了的解决 自底向上（执行）——逐步组建复杂系统的有效测试方法代码实现程序总体框架及步骤 步骤1：打印程序的介绍性信息 - printInfo() 步骤2：获得程序运行参数：proA, proB, n - getInputs() 步骤3：利用球员A和B的能力值，模拟n局比赛 - simNGames() 步骤4：输出球员A和B获胜比赛的场次及概率 - printSummary() 全代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from random import randomdef printIntro(): print("这个程序模拟两个选手A和B的某种竞技比赛") print("程序运行需要A和B的能力值（以0到1之间的小数表示）")def getInputs(): a = eval(input("请输入选手A的能力值（0-1）：")) b = eval(input("请输入选手B的能力值（0-1）：")) n = eval(input("模拟比赛的场次：")) return a, b, ndef printSummary(winsA, winsB): n = winsA + winsB print("竞技分析开始，共模拟&#123;&#125;场比赛".format(n)) print("选手A获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;".format(winsA, winsA/n)) print("选手B获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;".format(winsB, winsB/n))def gameOver(a, b): return a==15 or b==15def simOneGame(probA, probB): scoreA, scoreB = 0, 0 serving ="A" while not gameOver(scoreA,scoreB): if serving == "A": if random() &lt; probA: scoreA += 1 else: serving = "B" else: if random() &lt; probB: scoreB += 1 else: serving = "A" return scoreA, scoreBdef simNGames(n, probA, probB): winsA, winsB = 0, 0 for i in range(n): scoreA, scoreB = simOneGame(probA, probB) if scoreA &gt; scoreB: winsA += 1 else: winsB += 1 return winsA, winsBdef main(): printIntro() probA, probB, n = getInputs() winsA, winsB = simNGames(n, probA, probB) printSummary(winsA, winsB)main() 结果展示 举一反三 理解自顶向下和自底向上 理解自顶向下的设计思维：分而治之 理解自底向上的执行思维：模块化集成 自顶向下是“系统”思维的简化 应用问题的扩展 扩展比赛参数，增加对更多能力对比情况的判断 扩展比赛设计，增加对真实比赛结果的预测 扩展分析逻辑，反向推理，用胜率推算能力？ Python程序设计思维计算思维第3种人类思维特征 逻辑思维：推理和演绎，数学为代表，A-&gt;B B-&gt;C A-&gt;C 实证思维：实验和验证，物理为代表，引力波&lt;-实验 计算思维：设计和构造，计算机为代表，汉诺塔递归 计算思维（Computational Thinking）：抽象问题的计算过程，利用计算机自动化求解，是基于计算机的思维方式。计算思维基于计算机强大的算力及海量数据，抽象计算过程，关注设计和构造，而非因果。 计算生态与Python语言 以开源项目为代表的大量第三方库 库的建设经过野蛮生长和自然选择 库之间相互关联使用，依存发展 社区庞大，新技术更迭迅速 计算生态的价值 加速科技类应用创新的重要支撑 发展科技产品商业价值的重要模式 国家科技体系安全和稳固的基础 基本的程序设计模式IPO模块化设计配置化设计 Python第三方库安装Python社区：https://pypi.org 安装第三方库： 主要方法：使用pip命令 集成安装方法 文件安装方法 Anaconda： https://www.continuum.io 支持近800个第三方库 包含多个主流工具 适合数据计算领域开发 UCI页面： http://www.lfd.uci.edu/~gohlke/pythonlibs/ 在UCI页面上搜索&lt;库名称&gt; 下载对应版本的文件 使用pip install &lt;文件名&gt;安装 os库的使用os库基本介绍os库提供通用的、基本的操作系统交互功能 os库是Python标准库，包含几百个函数 常用路径操作、进程管理、环境参数等几类 路径操作：os.path子库，处理文件路径及信息 进程管理：启动系统中其他程序 环境参数：获得系统软硬件信息等环境参数 os库的路径操作os.path子库以path为入口，用于操作和处理文件路径| 函数 | 描述 || ————————— | ——————————— || os.path.abspath(path) | 返回path在当前系统中的绝对路径 || os.path.normpath(path) | 归一化path的表示形式，统一用\\分隔路径 || os.path.relpath(path) | 返回当前程序与文件之间的相对路径（relative path）|| os.path.dirname(path) | 返回path中的目录名称 || os.path.basename(path) | 返回path中最后的文件名称 || os.path.join(path,*paths) | 组合path与paths，返回一个路径字符串 || os.path.exists(path) | 判断path对应文件或目录是否存在，返回True或False || os.path.isfile(path) | 判断path所对应是否为已存在的文件，返回True或False|| os.path.isdir(path) | 判断path所对应是否为已存在的目录，返回True或False || os.path.getatime(path) | 返回path对应文件或目录上一次的访问时间 || os.path.getmtime(path) | 返回path对应文件或目录最近一次的修改时间 || os.path.getctime(path) | 返回path对应文件或目录创建时间 || os.path.getsize(path) | 返回path对应文件的大小，以字节为单位 | os库的进程管理1os.system(command) 执行程序或命令command 在Windows操作系统中，返回值为cmd调用的返回信息 os库的环境参数获取或改变系统环境信息| 函数 | 描述 || —————- | ———————————————– || os.chdir(path) | 修改当前程序的操作路径 || os.getcwd() | 返回程序的当前路径 || os.getlogin() | 获得当前系统登录用户名称 || os.cpu_count() | 获得当前系统CPU数量 || os.urandom(n) | 获得n个字节长度的随机字符串，通常用于加解密运算 | 实例：第三方库安装脚本问题分析 需求：批量安装第三方库需要人工干预，能否自动安装？ 自动执行pip逐一根据需求安装 库名 用途 pip安装指令 NumPy N维数据表示和运算 pip install numpy Matplotlib 二维数据可视化 pip install matplotlib PIL 图像处理 pip install pillow Scikit-Learn 机器学习和数据挖掘 pip install sklearn Requests HTTP协议访问及网络爬虫 pip install requests Jieba 中文分词 pip install jieba Beautiful Soup HTML和XML解析器 pip install beautifulsoup4 Wheel Python 第三方库文件打包工具 pip install wheel PyInstaller 打包Python源文件为可执行文件 pip install pyinstall Flask 轻量级Web开发框架 pip install flask WeRoBot 微信机器人开发框架 pip install werobot SymPy 数学符号计算工具 pip install sympy Pandas 高效数据分析和计算 pip install pandas Networkx 复杂网络和图结构的建模和分析 pip install networkx PyQt5 基于Qt的专业级GUI开发框架 pip install pyqt5 PyOpenGL 多平台OpenGL开发接口 pip install pyopengl PyPDF2 PDF文件内容提取及处理 pip install pypdf2 docopt Python命令行解析 pip install docopt PyGame 简单小游戏开发框架 pip install pygame 实例解析123456789101112#BatchInstall.pyimport oslibs = &#123;"numpy","matplotlib","pillow","sklearn","requests",\ "jieba","beautifulsoup4","wheel","networkx","sympy",\ "pyinstaller","django","flask","werobot","pyqt5",\ "pandas","pyopengl","pypdf2","docopt","pygame"&#125;try: for lib in libs: os.system("pip install" + lib) print("Successful")except: print("Failed Somehow") 举一反三自动化脚本+ 编写各类自动化运行程序的脚本，调用已有程序 扩展应用：安装更多第三方库，增加配置文件 扩展异常检测：捕获更多异常类型，程序更稳定友好]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python(7)文件和数据格式化]]></title>
    <url>%2F2019%2F04%2F04%2Fpython-7-%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[文件的使用文件的类型文件的理解文件是数据的抽象和集合 文件是存储在辅助存储器上的数据序列 文件是数据存储的一种形式 文件展现形态：文本文件和二进制文件 文本文件 vs 二进制文件 文本文件和二进制文件只是文件的展示方式 本质上，所有文件都是二进制形式存储 形式上，所有文件采用两种方式展示 文本文件 由单一特定编码组成的文件，如UTF-8编码 由于存在编码，也被看成是存储着的长字符串 适用于例如：.txt文件、.py文件 二进制文件 直接由比特0和1组成，没有统一字符编码 一般存在二进制0和1的组织结构，即文件格式 适用于例如：.png文件、.avi文件等 文件的打开和关闭文件处理的步骤：打开-操作-关闭 123sequenceDiagram文件的存储状态-&gt;&gt;文件的占用状态: a = open( , )文件的占用状态-&gt;&gt;文件的存储状态: a.close() 文件打开以后就可以对文件进行读写 123456789//读文件函数a.read(size)a.readline(size)a.readlines(hint)//写文件函数a.write(s)a.writelines(lines)a.seek(offset) 文件路径1&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;) 打开模式 文件的打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 ‘+’ 与r/w/x/a一同使用，在原功能基础上增加同时读写功能 文件的关闭1&lt;文件名&gt;.close() 文件内容的读取 操作方法 描述 .read(size=-1) 读入全部内容，如果给出参数，读入前size长度 .readline(size=-1) 读入全部内容，如果给出参数，读入该行前size长度 .readlines(hint=-1) 读入文件所有行，以每行为元素形成列表，如果给出参数，读入前hint行 文件的全文本操作 遍历全文本：方法一 12345fname = input("请输入要打开的文件名称：")fo = open(fname,"r")txt = fo.read()#对全文txt进行处理fo.close() 遍历全文本：方法二 1234567fname = input("请输入要打开的文件名称：")fo = open(fname,"r")txt = fo.read(2)while txt != "": #对txt进行处理 txt = fo.read(2)fo.close() 文件的逐行操作 逐行遍历文件：方法一 12345fname = input("请输入要打开的文件名称：")fo = open(fname,"r")for line in fo.readlines(): print(line)fo.close() 逐行遍历文件：方法二 12345fname = input("请输入要打开的文件名称：")fo = open(fname,"r")for line in fo: print(line)fo.close() 数据的文件写入 操作方法 描述 .write(s) 向文件写入一个字符串或字节流 .writelines(lines) 将一个元素全为字符串的列表写入文件 .seek(offset) 改变当前文件操作指针的位置，offset含义如下：0-文件开头，1-当前位置，2-文件结尾 123456fo = open("output.txt","w+")ls = ["中国","法国","美国"]fo.writelines(ls)for line in fo: print(line)fo.close() 此时控制台没有任何输出 1234567fo = open("output.txt","w+")ls = ["中国","法国","美国"]fo.writelines(ls)fo.seek(0)for line in fo: print(line)fo.close() 此时输出“中国法国美国” 实例：自动轨迹绘制问题分析 需求：根据脚本来绘制图形 不是写代码而是数据绘制图形 数据脚本是自动化最重要的第一步 基本思路 步骤1：定义数据文件格式（接口） 步骤2：编写程序，根据文件接口解析参数绘制图形 步骤3：编制数据文件 编写程序12345678910111213141516171819202122#AutoTraceDraw.pyimport turtle as tt.title('自动轨迹绘制')t.setup(800,600,0,0)t.pencolor("red")t.pensize(5)#数据读取datals = []f = open("data.txt")for line in f: line = line.replace("\n","") datals.append(list(map(eval, line.split(","))))#自动绘制for i in range(len(datals)): t.pencolor(datals[i][3],datals[i][4],datals[i][5]) t.fd(datals[i][0]) if datals[i][1]: t.right(datals[i][2]) else: t.left(datals[i][2]) 数据文件data.txt 123456789101112131415300,0,144,1,0,0300,0,144,0,1,0300,0,144,0,0,1300,0,144,1,1,0300,0,108,0,1,1184,0,72,1,0,1184,0,72,0,0,0184,0,72,0,0,0184,0,72,0,0,0184,1,72,1,0,1184,1,72,0,0,0184,1,72,0,0,0184,1,72,0,0,0184,1,72,0,0,0184,1,720,0,0,0 运行结果/%E8%87%AA%E5%8A%A8%E8%BD%A8%E8%BF%B9%E7%BB%98%E5%88%B6.jpg) 一维数据的格式化和处理数据组织的维度从一个数据到一组数据：一个数据表达一个含义，一组数据表达一个或多个含义 一维数据：由对等关系的有序或无序数据构成，采用线性方式组织，对应列表、数组、集合等概念。 二维数据：由多个一维数据构成，是一维数据的组合形式。表格是典型的二维数据。 多维数据：由一维或二维数据在新的维度上扩展形成 高维数据：键值对 数据的操作周期：存储&lt;->表示&lt;->操作 一维数据的表示如果数据间有序：使用列表类型 列表类型可以表达一维有序数据 for循环可以遍历数据，进而对每个数据进行处理 如果数据间无序：使用集合类型 集合类型可以表达一维无需数据 for循环可以遍历数据，进而对每个数据进行处理 一维数据的存储 存储方式一：空格分隔 使用一个或多个空格分隔进行存储，不换行 缺点：数据中不能存在空格 存储方式二：逗号分隔 使用英文半角逗号分隔数据进行存储，不换行 缺点：数据中不能有英文逗号 存储方式三：其他方式 使用其他符号或符号组合分隔，建议采用特殊符号 缺点：需要根据数据特点定义，通用性较差 一维数据的处理从空格分割的文件中读入数据123txt = open(fname).read()ls = txt.split()f.close() 从特殊符号分割的文件中读入数据123txt = open(fname).read()ls = txt.split("$")f.close() 采用空格分隔方式将数据写入文件1234ls = ["中国","美国","日本"]f = open(fname,'w')f.write(' '.join(ls))f.close() 二维数据的格式化和处理二维数据的表示使用列表类型（二维列表） 使用两层for循环遍历每个元素 外层列表中每个元素可以对应一行，也可以对应一列 CSV格式与二维数据的存储CSV：Comma-Separated Values 国际通用的一二维数据存储格式，一般.csv扩展名 每行一个一维数据，采用逗号分隔，无空行 Excel可读入输出，一般编辑软件都可以产生 如果某个元素确缺失，逗号仍要保留 二维数据的表头可以作为数据存储，也可以另行存储 二维数据的存储 按行存或按列存都可以，具体由程序决定 一般索引习惯：ls[row][column]，先行后列 根据一般习惯，外层列表每个元素是一行，按行存 二维数据的处理从CSV文件中读入数据 123456fo = open(fname)ls =[]for line in fo: line = line.replace("\n","") ls.append(line.split(","))fo.close() 将数据写入CSV文件 12345ls = [[],[],[]] #二维列表f.open(fname,'w')for item in ls: f.write(','.join(item) + '\n')f.close() 二维数据的逐一处理 1234ls = [[],[],[]] #二维列表for row in ls: for column in row: print(ls[row][column]) wordcloud库的使用基本介绍wordcloud是优秀的词云展示的第三方库，词云以词语为基本单位，更加直观和艺术的展示文本。 安装命令1pip install wordcloud 使用说明wordcloud库把词云当作一个WordCloud对象 wordcloud.WordCloud()代表一个文本对应的词云 可以根据文本中词语出现的频率等参数绘制词云 词云的形状、尺寸和颜色都可以设定 wordcloud库常规方法1w = wordcloud.WordCloud() 以WordCloud对象为基础 配置参数、加载文本、输出文件 方法 描述 w.generate(txt) 向WordCloud对象w中加载文本txt，w.generate(&quot;python and wordcloud&quot;) w.to_file(filename) 将词云输出成图像文件，.png或.jpg格式，w.to_file(&quot;outfile.png&quot;) 步骤1：配置对象参数 步骤2：加载词云文本 步骤3：输出词云文件 1234import wordcloudc = wordcloud.WordCloud()c.generate("wordcloud by python")c.to_file("pywordcloud.png") 从文本到图片，wordcloud做了哪些事情呢？ 分隔：以空格分隔单词 统计：单词出现次数并过滤 字体：根据统计配置字号 布局：颜色环境尺寸 wordcloud配置对象参数1w = wordcloud.WordCloud(&lt;参数&gt;) 参数 描述 width 指定词云对象生成图片的宽度，默认400像素 height 指定词云对象生成图片的高度，默认200像素 min_font_size 指定词云中字体的最小字号，默认4号 max_font_size 指定词云中字体的最大字号，根据高度自动调节 font_step 指定词云中字体字号的不进间隔，默认为1 font_path 指定字体文件的路径，默认None max_words 指定词云显示的最大单词数量，默认为200 stop_words 指定词云的排除词列表，即不显示的单词列表 mask 指定词云形状，默认为长方形，需要引用imread()函数 background_color 指定词云图片的背景颜色，默认为黑色 1234#指定词云形状，默认为长方形，需要引用imread()函数from scipy.misc import imread mk = imread("pic.png")w = wordcloud.WordCloud(mask = mk) 两个小demo123456import wordcloudtxt = "life is short, you need python"w = wordcloud.WordCloud( \ background_color = "white")w.generate(txt)w.to_file("d:/pywordcloud.png") /pywordcloud.png) 12345678910import jiebaimport wordcloudtxt = "程序设计语言是计算机能够理解和\识别用户操作意图的一种交互体系,它按照\特定规则组织计算机指令,使计算机能够自\动进行各种运算处理。"w = wordcloud.WordCloud( width = 1000, \ font_path = "msyh.ttc", height = 700)w.generate(" ".join(jieba.lcut(txt)))w.to_file("d:/zhongwenciyun.jpg") /zhongwenciyun.jpg) 实例：政府工作报告词云问题分析直观理解政策文件 需求：对于政府工作报告等政策文件，如何直观理解？ 体会直观的价值：生成词云 &amp; 优化词云 12graph LR政府工作报告等文件 --&gt; 有效展示的词云 基本思路和代码实现 步骤1：读取文件，分词整理 步骤2：设置并输出词云 步骤3：观察结果，优化迭代 12345678910111213#GovRpWordCloudv1.pyimport jiebaimport wordcloudf = open("关于实施乡村振兴战略的意见.txt","r",encoding="utf-8")#f = open("新时代中国特色社会主义.txt","r",encoding="utf-8")t = f.read()f.close()ls = jieba.lcut(t)txt = " ".join(ls)#w = wordcloud.WordCloud(max_words = 15,font_path = "msyh.ttc",width = 1000,height = 700,background_color = "white")w = wordcloud.WordCloud(font_path = "msyh.ttc",width = 1000,height = 700,background_color = "white")w.generate(txt)w.to_file("GovRpWordCloudv1.png") 运行程序后，两个报告的词云如下： /GovRpWordCloudv1%E4%B8%AD%E7%89%B9.png) /GovRpWordCloudv1%E5%86%9C%E6%9D%91.png) 增加参数max_words=15，结果如下： /GovRpWordCloudv1%E4%B8%AD%E7%89%B915.png) /GovRpWordCloudv1%E5%86%9C%E6%9D%9115.png) 增加形状mask = mask，词云图更加漂亮：123456789101112131415#GovRpWordCloudv1.pyimport jiebaimport wordcloudfrom scipy.misc import imreadmask = imread("chinamap.jpg")#mask = imread("fivestars.png")f = open("关于实施乡村振兴战略的意见.txt","r",encoding="utf-8")#f = open("新时代中国特色社会主义.txt","r",encoding="utf-8")t = f.read()f.close()ls = jieba.lcut(t)txt = " ".join(ls)w = wordcloud.WordCloud(mask = mask,font_path = "msyh.ttc",width = 1000,height = 700,background_color = "white")w.generate(txt)w.to_file("GovRpWordCloudv1.png") 结果展示：/GovRpWordCloudv1%E4%B8%AD%E7%89%B9%E4%BA%94%E6%98%9F.png) /GovRpWordCloudv1%E5%86%9C%E6%9D%91%E5%9C%B0%E5%9B%BE.png) 扩展能力 了解wordcloud更多参数，扩展词云能力 特色词云：设计一款属于自己的特色词云风格 更多文件：用更多文件练习词云生成 练习素材下载：新时代中国特色社会主义.txt/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89.txt)关于实施乡村振兴战略的意见.txt/%E5%85%B3%E4%BA%8E%E5%AE%9E%E6%96%BD%E4%B9%A1%E6%9D%91%E6%8C%AF%E5%85%B4%E6%88%98%E7%95%A5%E7%9A%84%E6%84%8F%E8%A7%81.txt)chinamap.jpg/chinamap.jpg)fivestars.png/fivestars.png)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python(6)组合数据类型]]></title>
    <url>%2F2019%2F04%2F04%2Fpython-6-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[集合类型及操作集合类型的定义集合类型的定义：集合是多个元素的无序组合 集合类型与数学中的集合概念一致 集合元素之间无序，每个元素唯一，不存在相同元素 集合元素不可更改，不能是可变数据类型 集合用大括号{}表示，元素间用逗号分隔 建立集合类型用{}或set() 建立空集合类型，必须使用set() 12345678&gt;&gt;&gt; A = &#123;"python",123,("python",123)&#125; #使用&#123;&#125;建立集合&#123;'python', ('python', 123), 123&#125;&gt;&gt;&gt; B = set("pypy123") #使用set()建立集合&#123;'2', '3', 'p', 'y', '1'&#125;&gt;&gt;&gt; C = &#123;"python",123,"python",123&#125;&#123;'python', 123&#125; 重点 集合用大括号{}表示，元素间用逗号分隔 集合元素之间无序 集合中每个元素唯一，不存在相同元素 集合操作符集合间操作：并差交补 操作符及应用 描述 `S\ T` 返回一个新集合，包括在集合S和T中的所有元素 S-T 返回一个新集合，包括在集合S但不在T中的元素 S&amp;T 返回一个新集合，包括同时在集合S和T中的元素 S^T 返回一个新集合，包括集合S和T中的非相同元素 S&lt;=T或S&lt;T 返回True/False,判断S和T的子集关系 S&gt;=T或S&gt;T 返回True/False,判断S和T的包含关系 4个增强操作符 操作符及应用 描述 `S\ =T` 更新集合S，包括在集合S和T中的所有元素 S-=T 更新集合S，包括在集合S但不在T中的元素 S&amp;=T 更新集合S，包括同时在集合S和T中的元素 S^=T 更新集合S，包括集合S和T中的非相同元素 123456789101112&gt;&gt;&gt; A = &#123;"p","y",123&#125;&gt;&gt;&gt; B = set("pypy123")&gt;&gt;&gt; A - B&#123;123&#125;&gt;&gt;&gt; B - A&#123;'2', '3', '1'&#125;&gt;&gt;&gt; A &amp; B&#123;'y', 'p'&#125;&gt;&gt;&gt; A | B&#123;'2', '3', 'p', 'y', 123, '1'&#125;&gt;&gt;&gt; A ^ B&#123;'2', '3', 123, '1'&#125; 集合处理方法 操作函数或方法 描述 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x，如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回集合S的一个副本 len(S) 返回集合S的元素个数 x in S 判断S中元素x，x在集合S中，返回True，否则返回False x not in S 判断S中元素x，x不在集合S中，返回False，否则返回True set(x) 将其他类型变量x转换为集合类型 12345&gt;&gt;&gt; A = &#123;"p","y",123&#125;&gt;&gt;&gt; for item in A: print(item,end="")y123p 123456789&gt;&gt;&gt; try: while True: print(A.pop(), end="") except: passy123p&gt;&gt;&gt; Aset() 集合类型应用场景包含关系比较 1234&gt;&gt;&gt; "p" in &#123;"p","y",123&#125;True&gt;&gt;&gt; &#123;"p","y"&#125; &gt;= &#123;"p","y",123&#125;False 数据去重：集合类型所有元素无重复 1234567&gt;&gt;&gt; ls = ["p","p","y","y",123]&gt;&gt;&gt; s = set(ls)&gt;&gt;&gt; s&#123;'y', 123, 'p'&#125;&gt;&gt;&gt; lt = list(s)&gt;&gt;&gt; lt['y', 123, 'p'] 序列类型及操作序列类型定义：序列是具有先后关系的一组元素 序列是一维元素的向量，元素类型可以不同 类似数学元素序列 元素间由序号引导，通过下标访问序列的特定元素 序列是一个基类类型： graph LR 序列类型-->字符串类型 序列类型-->元组类型 序列类型-->列表类型 序列类型通用操作符 操作符及应用 描述 x in s 如果x是序列s的元素，则返回True，否则返回False x not in s 如果x是序列s的元素，则返回False，否则返回True s + t 连接两个序列s和t s*n 或 n*s 将序列s复制n次 s[i] 索引，返回s中第i个元素，i是序列的序号 s[i:j]或s[i:j:k] 切片，返回序列s中第i到j以k为步长的元素子序列 12345678#::-1可以取反&gt;&gt;&gt; ls = ["python",123,".io"]&gt;&gt;&gt; ls[::-1]['.io', 123, 'python']&gt;&gt;&gt; s = "python123.io"&gt;&gt;&gt; s[::-1]'oi.321nohtyp' 序列类型通用函数和方法5个函数和方法 函数和方法 描述 len(s) 返回序列s的长度 min(s) 返回序列s中的最小元素，s中的元素需要可比较 max(s) 返回序列s中的最大元素，s中的元素需要可比较 s.index(x)或s.index(x,i,j) 返回序列s从i开始到j位置中第一次出现元素x的位置 s.count(x) 返回序列s中出现x的总次数 123456&gt;&gt;&gt; ls = ["python",123,".io"]&gt;&gt;&gt; len(ls)3&gt;&gt;&gt; s = "python123.io"&gt;&gt;&gt; max(s)'y' 元组类型及操作元组类型的定义元组是序列类型的一种扩展 元组是一种序列类型，一旦创建就不能被修改 使用小括号()或tuple()创建，元素间用逗号,分隔 可以使用或不使用小括号 1234567&gt;&gt;&gt; creature = "cat","dog","tiger","human"&gt;&gt;&gt; creature('cat', 'dog', 'tiger', 'human')&gt;&gt;&gt; color = (0x001100,"blue",creature)&gt;&gt;&gt; color(4352, 'blue', ('cat', 'dog', 'tiger', 'human')) 元组类型操作 元组继承序列类型的全部通用操作 因为元组创建后不能修改，所以没有特殊操作 1234567&gt;&gt;&gt; creature = "cat","dog","tiger","human"&gt;&gt;&gt; creature[::-1]('human', 'tiger', 'dog', 'cat')&gt;&gt;&gt; color = (0x001100,"blue",creature)&gt;&gt;&gt; color[-1][2]'tiger' 列表类型及操作列表类型定义列表是序列类型的一种扩展，十分常用 列表是一种序列类型，创建后可以随意被修改 使用方括号[]或list()创建，元素间用逗号,分隔 可以使用或不使用方括号 12345678&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; ls['cat', 'dog', 'tiger', 1024]&gt;&gt;&gt; lt = ls&gt;&gt;&gt; lt['cat', 'dog', 'tiger', 1024]#赋值并没有创建新列表，而相当于重新命名（类似指针） 列表类型操作函数和方法 函数和方法 描述 ls[i] = x 替换列表ls第i元素为x ls[i:j:k] = lt 用列表lt替换ls切片后所对应元素子列表 del ls[i] 删除列表ls第i元素 del ls[i:j:k] 删除列表ls中第i到第j以k为步长的元素 ls += lt 更新列表ls，将lt列表的元素增加到ls中 ls *= n 更新列表ls，其元素重复n次 123456789&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; ls[1:2] = [1,2,3,4]&gt;&gt;&gt; ls['cat', 1, 2, 3, 4, 'tiger', 1024]&gt;&gt;&gt; del ls[::3]&gt;&gt;&gt; ls[1, 2, 4, 'tiger']&gt;&gt;&gt; ls*2[1, 2, 4, 'tiger', 1, 2, 4, 'tiger'] 函数或方法 描述 ls.append(x) 在列表ls最后增加一个元素x ls.clear() 删除列表ls中的所有元素 ls.copy() 生成一个新列表，赋值ls中所有元素 ls.insert(i,x) 在列表ls的第i位置增加元素x ls.pop(i) 将列表ls中第i位置元素取出并删除该元素 ls.remove(x) 将列表ls中出现的第一个元素x删除 ls.reverse() 将列表ls中的元素反转 12345678910&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; ls.append(1234)&gt;&gt;&gt; ls['cat', 'dog', 'tiger', 1024, 1234]&gt;&gt;&gt; ls.insert(3,"human")&gt;&gt;&gt; ls['cat', 'dog', 'tiger', 'human', 1024, 1234]&gt;&gt;&gt; ls.reverse()&gt;&gt;&gt; ls[1234, 1024, 'human', 'tiger', 'dog', 'cat'] 序列类型应用场景 元组用于元素不改变的应用场景，更多应用于固定搭配场景 列表更加灵活，它是最常用的序列类型 最主要作用：表示一组有序数据，进而操作它们 元素遍历12345for item in ls : &lt;语句块&gt; for item in tp : &lt;语句块&gt; 数据保护如果不希望数据被程序所改变，转换成元组类型1234&gt;&gt;&gt; ls = ["cat","dog","tiger",1024]&gt;&gt;&gt; lt = tuple(ls)&gt;&gt;&gt; lt('cat', 'dog', 'tiger', 1024) 实例：基本统计值计算实例：基本统计值计算12345678910111213141516171819202122232425262728293031323334353637#CalStatisticsV1.py#获取用户不定长度的输入def getNum(): nums = [] iNumStr = input("请输入数字（回车退出）：") while iNumStr != "": nums.append(eval(iNumStr)) iNumStr = input("请输入数字（回车退出）：") return nums#计算平均值def mean(numbers): s = 0.0 for num in numbers: s = s + num return s / len(numbers)#计算方差def dev(numbers, mean): sdev = 0.0 for num in numbers: sdev = sdev + (num - mean)**2 return pow(sdev / (len(numbers)-1), 0.5)#计算中位数def median(numbers): sorted(numbers) size = len(numbers) if size % 2 == 0: med = (numbers[size//2-1] + numbers[size//2])/2 else: med = numbers[size//2] return medn = getNum()m = mean(n)print("平均值:&#123;&#125;,方差:&#123;:.2&#125;,中位数:&#123;&#125;.".format(m, dev(n,m), median(n))) 字典类型及操作字典类型定义理解“映射”：映射是一种键（索引）和值（数据）的对应字典类型是“映射”的体现 键值对：键是数据索引的扩展 字典是键值对的集合，键值对之间无序 采用大括号{}和dict()创建，键值对用冒号:表示 12345&gt;&gt;&gt; d = &#123;"中国":"北京","美国":"华盛顿","法国":"巴黎"&#125;&gt;&gt;&gt; d&#123;'中国': '北京', '美国': '华盛顿', '法国': '巴黎'&#125;&gt;&gt;&gt; d["中国"]'北京' 字典类型操作函数及方法 函数或方法 描述 del d[k] 删除字典d中键k对应的数据值 k in d 判断键k是否在字典d中，如果在则返回True，否则False d.keys() 返回字典d所有的键信息 d.values() 返回字典d所有的值信息 d.items() 返回字典d所有的键值对信息 123456789&gt;&gt;&gt; d = &#123;"中国":"北京","美国":"华盛顿","法国":"巴黎"&#125;&gt;&gt;&gt; "中国" in dTrue&gt;&gt;&gt; d.keys()dict_keys(['中国', '美国', '法国'])&gt;&gt;&gt; d.values()dict_values(['北京', '华盛顿', '巴黎'])&gt;&gt;&gt; d.items()dict_items([('中国', '北京'), ('美国', '华盛顿'), ('法国', '巴黎')]) 函数或方法 描述 d.get(k, ) 键k存在，则返回相应值，不在则返回值 d.pop(k, ) 键k存在，则取出相应值，不在则返回值 d.popitem() 随机从字典d中取出一个键值对，以元组形式返回 d.clear() 删除所有键值对 len(d) 返回字典d中元素的个数 123456&gt;&gt;&gt; d.get("中国","伊斯兰堡")'北京'&gt;&gt;&gt; d.get("巴基斯坦","伊斯兰堡")'伊斯兰堡'&gt;&gt;&gt; d.popitem()('法国', '巴黎') 字典类型应用场景映射的表达 映射无处不在，键值对无处不在 例如：统计数据出现的次数，数据是键，次数是值 最主要作用：表达键值对数据，进而操作它们 元素遍历12for k in d: &lt;语句块&gt; jieba库的使用jieba库的基本介绍概述：jieba是优秀的中文分词第三方库 中文文本需要通过分词获得单个的词语 jieba是优秀的中文分词第三方库，需要额外安装 jieba库提供三种分词模式，最简单只需掌握一个函数 jieba库的安装1pip install jieba jieba分词的原理jieba分词依靠中文词库 利用一个中文词库，确定汉字之间的关联概率 汉字之间概率大的组成词组，形成分词结果 除了分词，用户还可以添加自定义的词组 jieba分词的三种模式精确模式、全模式、搜索引擎模式 精确模式：把文本精确地切分开，不存在冗余单词 全模式：把文本中所有可能的词语都扫描出来，有冗余 搜索引擎模式：在精确模式基础上，对长词再次切分 jieba库常用函数 函数 描述 jiaba.lcut(s) 精确模式，返回一个列表类型的分词结果 jieba.lcut(s, cut_all=True) 全模式，返回一个列表类型的分词结果，存在冗余 jieba.lcut_for_search(s) 搜索引擎模式，返回一个列表类型的分词结果，存在冗余 jieba.add_word(w) 向分词词典增加新词w 123456789101112&gt;&gt;&gt; import jieba&gt;&gt;&gt; jieba.lcut("中国是一个伟大的国家")Building prefix dict from the default dictionary ...Dumping model to file cache C:\Users\dreamorz\AppData\Local\Temp\jieba.cacheLoading model cost 1.020 seconds.Prefix dict has been built succesfully.['中国', '是', '一个', '伟大', '的', '国家']&gt;&gt;&gt; jieba.lcut("中国是一个伟大的国家",cut_all=True)['中国', '国是', '一个', '伟大', '的', '国家']&gt;&gt;&gt; jieba.lcut_for_search("中华人民共和国是伟大的")['中华', '华人', '人民', '共和', '共和国', '中华人民共和国', '是', '伟大', '的']&gt;&gt;&gt; jieba.add_word("蟒蛇语言") jieba分词要点1jieba.lcut(s) 实例：文本词频统计（英文&amp;中文）Hamlet词频统计123456789101112131415161718#CalHamletV1.pydef getText(): txt = open("E:/python/hamlet.txt","r").read() txt = txt.lower() for ch in '!"#$%&amp;()*+,-./;:&lt;=&gt;?@[\\]^_&#123;|&#125;~': txt = txt.replace(ch, " ") return txthamletTxt = getText()words = hamletTxt.split()counts = &#123;&#125;for word in words: counts[word] = counts.get(word,0) + 1items = list(counts.items())items.sort(key=lambda x:x[1],reverse=True)for i in range(10): word, count = items[i] print("&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;".format(word, count)) 《三国演义》人物出场统计123456789101112131415161718192021222324252627#CalThreeKingdomsV1.pyimport jiebatxt = open("threekingdoms.txt","r",encoding="utf-8").read()excludes = &#123;"将军","却说","二人","不可","荆州","不能","如此","商议","如何","今日","不敢","魏兵","陛下","一人","军士","左右","军马","主公","引兵","次日","大喜","天下","东吴","于是"&#125;words = jieba.lcut(txt)counts = &#123;&#125;for word in words: if len(word) == 1: continue elif word == "诸葛亮" or word == "孔明曰": rword = "孔明" elif word == "关公" or word == "云长": rword = "关羽" elif word == "玄德" or word == "玄德曰": rword = "刘备" elif word == "孟德" or word == "丞相": rword = "曹操" else: rword = word counts[rword] = counts.get(rword,0) + 1for word in excludes: del counts[word]items = list(counts.items())items.sort(key=lambda x:x[1], reverse=True)for i in range(10): word, count = items[i] print("&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;".format(word, count)) 资料下载 hamlet.txt/hamlet.txt) threekingdoms.txt/threekingdoms.txt)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python(1)基本语法元素]]></title>
    <url>%2F2019%2F04%2F04%2Fpython-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[程序设计语言编程语言种类很多，但生命力强劲的却不多 编程语言有超过600种，绝大部分都不再被使用 C语言诞生于1972年，它是第一个被广泛使用的编程语言 Python语言诞生于1990年，它是最流行最好用的编程语言 编译和解释计算机执行源程序的两种方式：编译和解释 编译:将源代码一次性转换成目标代码的过程 解释:将源代码逐条转换成目标代码同时逐条运行的过程 程序的基本编写方法IPO程序的基本编写方法 I：Input 输入，程序的输入 P：Process 处理，程序的主要逻辑 O：Output 输出，程序的输出 编程解决问题的步骤 分析问题：分析问题的计算部分，想清楚 划分边界：划分问题的功能边界，规划IPO 设计算法：设计问题的求解算法，关注算法 编写程序：编写问题的计算程序，编程序 调试测试：调试程序使正确运行，运行调试 升级维护：适应问题的升级维护，更新完善 历史Guido van Rossum ，Python语言创立者2002年，Python 2.x2008年，Python 3.x “温度转换”实例需求分析两种温度体系的转换 摄氏度转换为华氏度 华氏度转换为摄氏度 问题分析设计算法根据华氏和摄氏温度定义，利用转换公式如下：C = ( F – 32 ) / 1.8F = C * 1.8 + 32其中， C表示摄氏温度， F表示华氏温度 代码实现1234567891011#TempConvert.pyTempStr = input("请输入带有符号的温度值: ")if TempStr[-1] in ['F', 'f']: C = (eval(TempStr[0:-1]) - 32)/1.8 print("转换后的温度是&#123;:.2f&#125;C".format(C))elif TempStr[-1] in ['C', 'c']: F = 1.8*eval(TempStr[0:-1]) + 32 print("转换后的温度是&#123;:.2f&#125;F".format(F))else: print("输入格式错误") 语法元素缩进缩进表达程序的格式框架 严格明确：缩进是语法的一部分，缩进不正确程序运行错误 所属关系：表达代码间包含和层次关系的唯一手段 长度一致：程序内一致即可，一般用4个空格或1个TAB 注释不被程序执行的辅助性说明信息 单行注释：以#开头，其后内容为注释 1# 这里是单行注释 多行注释：以’’’开头和结尾 12''' 这是多行注释第一行这是多行注释第二行 ''' 保留字被编程语言内部定义并保留使用的标识符 Python语言有35个保留字(也叫关键字)if, elif, else, in 保留字是编程语言的基本单词，大小写敏感if 是保留字，If 是变量 保留字 and elif import raise global as else in return nonlocal assert except is try True break finally lambda while False class for not with None continue from or yield async def if pass del await 数据类型数据类型：字符串、整数、浮点数、列表 语句与函数赋值语句：由赋值符号构成的一行代码分支语句：由判断条件决定程序运行方向的语句函数：根据输入参数产生不同输出的功能过程 输入函数 input()从控制台获得用户输入的函数 输出函数 print()以字符形式向控制台输出结果的函数 评估函数 eval()去掉参数最外侧引号并执行余下语句的函数]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy数据存取与函数]]></title>
    <url>%2F2019%2F04%2F04%2FNumpy%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HDFS客户端API]]></title>
    <url>%2F2019%2F04%2F04%2FHDFS%E5%AE%A2%E6%88%B7%E7%AB%AFAPI%2F</url>
    <content type="text"><![CDATA[手动导入需要用的jars，也可以使用maven。 1234567891011121314151617181920212223242526272829303132333435363738/** * HDFS的客户端api功能无非就是操作HDFS上的文件或文件夹 * * @author Administrator * */public class HdfsClientDemo &#123; FileSystem hdfsClient; @Before public void init() throws Exception &#123; Configuration conf = new Configuration(); conf.addResource("myconf.xml"); conf.set("dfs.replication", "2"); conf.set("dfs.blocksize", "32m"); // 创建一个HDFS客户端对象 hdfsClient = FileSystem.get(new URI("hdfs://hdp-nn-01:9000/"), conf, "root"); /** * 上传一个文件 */ @Test public void testPutFile() throws Exception &#123; hdfsClient.copyFromLocalFile(new Path("d:/jdk-8u191-linux-x64.tar.gz"), new Path("/jdk8.gz")); hdfsClient.close(); &#125; /** * 测试取文件 * * @throws Exception */ @Test public void testGetFile() throws Exception &#123; hdfsClient.copyToLocalFile(false, new Path("/jdk8.gz"), new Path("d:/"), true); hdfsClient.close(); &#125; 注意：HDFS客户端从HDFS上读取数据写入本地磁盘时，可以使用Hadoop自己开发的本地库操作，也可以使用java 的原生库来操作本地文件。 参数就是useRawLocalFileSystem，如果为true，则使用java原生库；false则使用Hadoop自己的本地库。如果要使用Hadoop的本地库来操作本地文件，要配置Hadoop在本地的环境。 123456789101112131415161718192021222324252627282930313233343536 /** * 文件夹创建 * * @throws Exception */ @Test public void testMkdir() throws Exception &#123; // 如果创建文件夹时，指定权限信息，但创建的结果并不会跟指定的信息完全一致，因为想指定的信息还会经过一个参数值的掩码运算 hdfsClient.mkdirs(new Path("/xxx/yyy"), new FsPermission((short) 777)); hdfsClient.close(); &#125; /** * 文件夹删除 * * @throws Exception */ @Test public void testDeldir() throws Exception &#123; hdfsClient.delete(new Path("/xxx"), true); hdfsClient.close(); &#125; /** * 文件夹重命名 * * @throws Exception */ @Test public void testRenamedir() throws Exception &#123; hdfsClient.rename(new Path("/xxx"), new Path("/ooo")); hdfsClient.close(); &#125;&#125;]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS基本配置属性]]></title>
    <url>%2F2019%2F04%2F04%2FHDFS%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[块大小HDFS中存储的文件块的块大小，默认128M 参数：dfs.blocksize 默认：134217728 此参数用于客户端程序，也就是说，HDFS里面存储的文件块的块大小完全由客户端决定 副本数量HDFS中存储的文件快可以有多个副本，默认3个 参数：dfs.replication 默认：3 此参数用于客户端程序，也就是说，HDFS里面存储的文件块的副本数完全由客户端决定 为什么要默认3个？第一个副本：存在离客户端系统最近的一台DataNode上；第二个副本：存在跟上一台DataNode相同的机架的另一台DataNode上；第三个副本：存在另一个机架上的某台DataNode上 NameNode元数据存储目录元数据存储目录就是NameNode的工作目录，其位置由以下参数决定： 参数：dfs.namenode.name.dir 默认：file://${hadoop.tmp.dir}/dfs/name 此参数是给服务端程序NameNode使用 此参数默认值在生产中并不合适，应该给NameNode专门配置一个安全的位置作为工作目录 正确做法：应该给NameNode配置多个目录，而且这多个目录应该挂载不同的磁盘1234&lt;property&gt;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;&lt;value&gt;/mnt/disk1,/mnt/disk2,/mnt/disk3,nfs://&lt;/value&gt;&lt;/property&gt; 配置多个目录后，NameNode会往个目录中写入==相同的数据==作为冗余备份 DataNode文件块存储目录DataNode的工作目录也是参数可配的： 参数：dfs.datanode.data.dir 默认：file://${hadoop.tmp.dir}/dfs/data 默认配置在生产系统中并不合适，应该让DataNode的工作目录指定到服务器上用于存储数据的多块数据磁盘上1234&lt;property&gt;&lt;name&gt;dfs.datanode.name.dir&lt;/name&gt;&lt;value&gt;/data/disk1,/data/disk2,/data/disk3&lt;/value&gt;&lt;/property&gt; 配置多个目录后，NameNode会往个目录中写入==不同的数据==，以扩大DataNode自身的容量 HDFS动态扩容扩容就是增加DataNode，DataNode可以在线扩容。 步骤 准备一台服务器，配置好环境：网络、IP、防火墙、免密登录、JDK； 从原集群的任意一台机器上复制Hadoop安装包到新机器上； 在原集群的slaves文件中添加新机器的主机名； 在新机器上启动DataNode即可。 DataNode启动方法 直接用start-dfs.sh 在新机器上手动启动一个DataNode进程：hadoop-daemon.sh start datanode]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flume+Kafka实时数据采集]]></title>
    <url>%2F2019%2F04%2F04%2FFlume-Kafka%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Flume的配置 12345678910111213141516171819# avro-memory-kafka.confavro-memory-kafka.sources = avro-sourceavro-memory-kafka.sinks = kafka-sinkavro-memory-kafka.channels = memory-channelavro-memory-kafka.sources.avro-source.type = avroavro-memory-kafka.sources.avro-source.bind = bigdata-01avro-memory-kafka.sources.avro-source.port = 44444avro-memory-kafka.sinks.kafka-sink.type = org.apache.flume.sink.kafka.KafkaSinkavro-memory-kafka.sinks.kafka-sink.brokerList = bigdata-01:9092avro-memory-kafka.sinks.kafka-sink.topic = hello_topicavro-memory-kafka.sinks.kafka-sink.batchSize = 5avro-memory-kafka.sinks.kafka-sink.requiredAcks = 1avro-memory-kafka.channels.memory-channel.type = memoryavro-memory-kafka.sources.avro-source.channels = memory-channelavro-memory-kafka.sinks.kafka-sink.channel = memory-channel 启动Flume1234567891011flume-ng agent \--name avro-memory-kafka \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/avro-memory-kafka.conf \-Dflume.root.logger=INFO,consoleflume-ng agent \--name exec-memory-avro \--conf $FLUME_HOME/conf \--conf-file $FLUME_HOME/conf/exec-memory-avro.conf \-Dflume.root.logger=INFO,console 启动消费者进行监控1kafka-console-consumer.sh --zookeeper bigdata-01:2181 -topic hello_topic 向日志文件中追加内容123456789[root@bigdata-01 ~]# cd data/[root@bigdata-01 data]# lltotal 4-rw-r--r--. 1 root root 112 Feb 6 05:37 data.log[root@bigdata-01 data]# echo hellospark &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark2 &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark3 &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark4 &gt;&gt; data.log [root@bigdata-01 data]# echo hellospark5 &gt;&gt; data.log 这时，消费者就可以消费到日志文件中的新内容了。 Flume的版本不同，配置文件（*.conf）需要配置的内容也不完全相同。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flume</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
</search>
